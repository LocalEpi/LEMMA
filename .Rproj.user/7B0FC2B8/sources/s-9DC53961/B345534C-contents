SEIR.old <- function (initial.new.exposures, initial.conditions, start.date, 
          end.date, params) 
{
  GetBeta <- function (dates, params, overall.gamma) 
  {
    num.days <- length(dates)
    num.param.sets <- nrow(params)
    multiplier <- matrix(1, nrow = num.days, ncol = num.param.sets)
    intervention.multiplier.str <- grep("^intervention[[:digit:]]+\\.multiplier$", 
                                        names(params), value = T)
    date.mat <- matrix(dates, nrow = num.days, ncol = num.param.sets)
    ExpandToDays <- function(param) matrix(param, nrow = num.days, 
                                           ncol = num.param.sets, byrow = T)
    for (int.mult.str in intervention.multiplier.str) {
      intervention.multiplier <- params[[int.mult.str]]
      intervention.smooth.days <- params[[sub("multiplier", 
                                              "smooth.days", int.mult.str)]]
      intervention.date <- params[[sub("multiplier", "date", 
                                       int.mult.str)]]
      stopifnot(!is.null(intervention.multiplier), !is.null(intervention.smooth.days), 
                !is.null(intervention.date))
      multiplier.mat <- ExpandToDays(intervention.multiplier^(1/intervention.smooth.days))
      index <- date.mat >= ExpandToDays(intervention.date) & 
        date.mat <= ExpandToDays(intervention.date + intervention.smooth.days - 
                                   1)
      multiplier[index] <- multiplier[index] * multiplier.mat[index]
    }
    cum.multiplier <- colCumprods(multiplier)
    prior.beta <- matrix(params$r0.initial * overall.gamma, nrow = num.days, 
                         ncol = num.param.sets, byrow = T)
    beta <- prior.beta * cum.multiplier
    return(beta)
  }
  AsInteger <- function (x) 
  {
    stopifnot(abs(round(x) - x) < 1e-04)
    as.integer(round(x))
  }
  GetDateIndex <- function (dates.to.find, all.dates) 
  {
    is.sorted <- function(x) !is.unsorted(x, strictly = T)
    stopifnot(dates.to.find %in% all.dates, is.sorted(dates.to.find), 
              is.sorted(all.dates))
    return(all.dates %in% dates.to.find)
  }
  if (is.numeric(initial.conditions)) {
    initial.conditions <- data.table(date = start.date, S = initial.conditions, 
                                     E = 0, IH = 0, IR = 0, R = 0, HP = 0, DC = 0)
  }
  num.param.sets <- nrow(params)
  if (is.null(initial.new.exposures)) {
    num.init.exp <- 1
  }
  else {
    stopifnot(nrow(initial.new.exposures) == num.param.sets)
    num.init.exp <- ncol(initial.new.exposures)
  }
  p <- params
  sigma <- 1/p$latent.period
  psi <- 1/p$hosp.length.of.stay
  gamma.r <- 1/p$illness.length.given.nonhosp
  gamma.h <- 1/(p$exposed.to.hospital - p$latent.period)
  stopifnot(p$exposed.to.hospital > p$latent.period)
  exposed.to.hospital <- AsInteger(p$exposed.to.hospital)
  exposed.to.discharge <- AsInteger(p$exposed.to.hospital + 
                                      p$hosp.length.of.stay)
  has.E <- p$latent.period > 0
  dates <- seq(start.date, end.date, by = "day")
  num.days <- length(dates)
  stopifnot(num.days > 1)
  overall.gamma <- gamma.r
  beta <- GetBeta(dates, params, overall.gamma)
  base.compartment.names <- c("S", "E", "IH", "IR", "R", "HP", 
                              "DC")
  empty.compartment <- array(NA_real_, dim = c(num.days, num.param.sets, 
                                               num.init.exp), dimnames = list(as.character(dates), NULL, 
                                                                              NULL))
  q <- sapply(base.compartment.names, function(z) empty.compartment, 
              simplify = F)
  d <- sapply(base.compartment.names, function(z) NULL)
  total.infected <- new.exposures <- empty.compartment
  new.admits.output <- new.discharges.output <- empty.compartment
  date.index <- GetDateIndex(initial.conditions$date, dates)
  stopifnot(identical(which(date.index), 1L), initial.conditions$date == 
              start.date)
  for (i in base.compartment.names) {
    q[[i]][date.index, , ] <- initial.conditions[[i]]
  }
  N <- sum(sapply(base.compartment.names, function(z) initial.conditions[[z]][1]))
  GetNewExposures <- function(day) {
    new.exp <- matrix(NA_real_, nrow = num.param.sets, ncol = num.init.exp)
    new.exp[day <= 0 & !is.na(day), ] <- 0
    valid <- day > 0 & !is.na(day)
    num.valid <- sum(valid)
    array.index <- cbind(pracma::repmat(cbind(day[valid], 
                                              seq_len(num.valid)), num.init.exp, 1), rep(seq_len(num.init.exp), 
                                                                                         each = num.valid))
    new.exp[valid, ] <- new.exposures[, valid, , drop = F][array.index]
    return(new.exp)
  }
  d$E <- new.infections <- new.admits <- new.discharges <- matrix(NA_real_, 
                                                                  nrow = num.param.sets, ncol = num.init.exp)
  uhr <- p$use.hosp.rate
  admit.from.day <- discharge.from.day <- rep(NA_integer_, 
                                              num.param.sets)
  for (tt in 1:num.days) {
    total.infected[tt, , ] <- q$IR[tt, , ] + q$IH[tt, , ] + 
      (p$patients.in.hosp.are.infectious) * q$HP[tt, , 
                                                 ]
    if (tt == num.days) 
      break
    if (tt == 1 && !is.null(initial.new.exposures)) {
      new.exposures[tt, , ] <- initial.new.exposures
    }
    else {
      new.exposures[tt, , ] <- beta[tt, ] * q$S[tt, , ] * 
        total.infected[tt, , ]/N
      new.exposures[tt, , ] <- pmax(new.exposures[tt, , 
                                                  ], 0)
      new.exposures[tt, , ] <- pmin(new.exposures[tt, , 
                                                  ], q$S[tt, , ])
      # cat("old code: tt = ", tt, "\n")
      # print(p[1])
      # cat("new.exposures=\n")
      # print(new.exposures)
      # if (tt == 3) {
      #   print(beta[tt, 1])
      #   print(q$S[tt, 1, ])
      #   print(total.infected[tt, 1, ])
      #   print(N)
      # }
    }
    new.nonhosp.recovered <- gamma.r * q$IR[tt, , ]
    d$S <- -new.exposures[tt, , ]
    d$E[has.E, ] <- new.exposures[tt, has.E, ] - sigma[has.E] * 
      q$E[tt, has.E, ]
    d$E[!has.E, ] <- 0
    new.infections[has.E, ] <- sigma[has.E] * q$E[tt, has.E, 
                                                  ]
    new.infections[!has.E, ] <- new.exposures[tt, !has.E, 
                                              ]
    new.admits[uhr, ] <- gamma.h[uhr] * q$IH[tt, uhr, ]
    new.discharges[uhr] <- psi[uhr] * q$HP[tt, uhr, ]
    admit.from.day[!uhr] <- (tt - exposed.to.hospital)[!uhr]
    discharge.from.day[!uhr] <- (tt - exposed.to.discharge)[!uhr]
    new.admits[!uhr, ] <- p$prop.hospitalized[!uhr] * GetNewExposures(admit.from.day)[!uhr]
    new.discharges[!uhr, ] <- p$prop.hospitalized[!uhr] * 
      GetNewExposures(discharge.from.day)[!uhr]
    d$IR <- new.infections * (1 - p$prop.hospitalized) - 
      new.nonhosp.recovered
    d$IH <- new.infections * p$prop.hospitalized - new.admits
    d$HP <- new.admits - new.discharges
    d$DC <- new.discharges
    d$R <- new.nonhosp.recovered
    total.d <- matrix(0, nrow = num.param.sets, ncol = num.init.exp)
    for (i in base.compartment.names) {
      q[[i]][tt + 1, , ] <- q[[i]][tt, , ] + d[[i]]
      total.d <- total.d + d[[i]]
    }
    stopifnot(abs(total.d) < 0.001)
    for (i in names(q)) {
      if (i == "IH") {
        stopifnot(q[[i]][tt, uhr, ] > -1e-05)
      }
      else {
        stopifnot(q[[i]][tt, , ] > -1e-05)
      }
      q[[i]][tt, , ] <- pmax(q[[i]][tt, , ], 0)
    }
    new.admits.output[tt, , ] <- new.admits
    new.discharges.output[tt, , ] <- new.discharges
  }
  icu <- as.vector(matrix(p$prop.icu, nrow = num.days, ncol = num.param.sets, 
                          byrow = T)) * q$HP
  list.return <- c(q, list(I = total.infected, icu = icu, vent = as.vector(matrix(p$prop.vent, 
                                                                                  nrow = num.days, ncol = num.param.sets, byrow = T)) * 
                             icu, R.total = q$R + q$DC, active.cases = q$E + q$IR + 
                             q$IH + q$HP, total.cases = q$E + q$IR + q$IH + q$R + 
                             q$HP + q$DC, new.admits = new.admits.output, new.discharges = new.discharges.output))
  names(list.return)[names(list.return) == "R"] <- "R.nonhosp"
  names(list.return)[names(list.return) == "HP"] <- "hosp"
  return(list.return)
}

Seir.old <- function (initial.new.exposures, initial.conditions, start.date, 
          end.date, params) 
{
  if (!is.null(initial.new.exposures)) {
    if (is.matrix(initial.new.exposures)) {
      stopifnot(nrow(initial.new.exposures) == nrow(params))
    }
    else {
      stopifnot(length(initial.new.exposures) == nrow(params))
      initial.new.exposures <- as.matrix(initial.new.exposures)
    }
  }
  stopifnot(end.date > start.date)
  list.return <- SEIR.old(initial.new.exposures, initial.conditions, 
                      start.date, end.date, params)
  num.param.sets <- dim(list.return$hosp)[2]
  num.init.exp <- dim(list.return$hosp)[3]
  if (num.init.exp == 1) {
    list.return <- lapply(list.return, drop)
    if (num.param.sets == 1) {
      return(cbind(date = seq(start.date, end.date, by = "day"), 
                   as.data.table(list.return)))
    }
    else {
      return(list.return)
    }
  }
  else {
    return(list.return)
  }
}