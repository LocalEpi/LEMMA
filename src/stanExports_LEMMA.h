// Generated by rstantools.  Do not edit by hand.

/*
    LEMMA is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    LEMMA is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with LEMMA.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#ifndef USE_STANC3
#define USE_STANC3
#endif
#include <rstan/rstaninc.hpp>
// Code generated by stanc v2.26.1-1-g67504470
#include <stan/model/model_header.hpp>
namespace model_LEMMA_namespace {
inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}
inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}
using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 
stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'LEMMA', line 76, column 2 to column 34)",
                                                      " (in 'LEMMA', line 77, column 2 to column 36)",
                                                      " (in 'LEMMA', line 78, column 2 to column 36)",
                                                      " (in 'LEMMA', line 79, column 2 to column 36)",
                                                      " (in 'LEMMA', line 80, column 2 to column 48)",
                                                      " (in 'LEMMA', line 81, column 2 to column 41)",
                                                      " (in 'LEMMA', line 82, column 2 to column 35)",
                                                      " (in 'LEMMA', line 83, column 2 to column 40)",
                                                      " (in 'LEMMA', line 84, column 2 to column 27)",
                                                      " (in 'LEMMA', line 85, column 2 to column 43)",
                                                      " (in 'LEMMA', line 86, column 2 to column 29)",
                                                      " (in 'LEMMA', line 87, column 2 to column 29)",
                                                      " (in 'LEMMA', line 88, column 2 to column 30)",
                                                      " (in 'LEMMA', line 92, column 2 to column 53)",
                                                      " (in 'LEMMA', line 95, column 2 to column 40)",
                                                      " (in 'LEMMA', line 96, column 2 to column 44)",
                                                      " (in 'LEMMA', line 97, column 2 to column 38)",
                                                      " (in 'LEMMA', line 98, column 2 to column 42)",
                                                      " (in 'LEMMA', line 99, column 2 to column 27)",
                                                      " (in 'LEMMA', line 100, column 2 to column 30)",
                                                      " (in 'LEMMA', line 103, column 6 to column 32)",
                                                      " (in 'LEMMA', line 102, column 32 to line 104, column 5)",
                                                      " (in 'LEMMA', line 102, column 4 to line 104, column 5)",
                                                      " (in 'LEMMA', line 101, column 19 to line 105, column 3)",
                                                      " (in 'LEMMA', line 101, column 2 to line 105, column 3)",
                                                      " (in 'LEMMA', line 108, column 4 to column 14)",
                                                      " (in 'LEMMA', line 109, column 4 to column 14)",
                                                      " (in 'LEMMA', line 110, column 4 to column 21)",
                                                      " (in 'LEMMA', line 111, column 4 to column 16)",
                                                      " (in 'LEMMA', line 112, column 4 to column 19)",
                                                      " (in 'LEMMA', line 113, column 4 to column 38)",
                                                      " (in 'LEMMA', line 114, column 4 to column 23)",
                                                      " (in 'LEMMA', line 115, column 4 to column 39)",
                                                      " (in 'LEMMA', line 116, column 4 to column 44)",
                                                      " (in 'LEMMA', line 117, column 4 to column 20)",
                                                      " (in 'LEMMA', line 118, column 4 to column 35)",
                                                      " (in 'LEMMA', line 119, column 4 to column 35)",
                                                      " (in 'LEMMA', line 120, column 15 to column 17)",
                                                      " (in 'LEMMA', line 120, column 4 to column 36)",
                                                      " (in 'LEMMA', line 121, column 15 to column 17)",
                                                      " (in 'LEMMA', line 121, column 4 to column 36)",
                                                      " (in 'LEMMA', line 123, column 6 to column 83)",
                                                      " (in 'LEMMA', line 124, column 6 to column 83)",
                                                      " (in 'LEMMA', line 122, column 21 to line 125, column 5)",
                                                      " (in 'LEMMA', line 122, column 4 to line 125, column 5)",
                                                      " (in 'LEMMA', line 126, column 4 to column 60)",
                                                      " (in 'LEMMA', line 127, column 4 to column 79)",
                                                      " (in 'LEMMA', line 129, column 4 to column 44)",
                                                      " (in 'LEMMA', line 130, column 4 to column 74)",
                                                      " (in 'LEMMA', line 131, column 4 to column 45)",
                                                      " (in 'LEMMA', line 132, column 4 to column 75)",
                                                      " (in 'LEMMA', line 133, column 4 to column 69)",
                                                      " (in 'LEMMA', line 134, column 4 to column 34)",
                                                      " (in 'LEMMA', line 135, column 4 to column 48)",
                                                      " (in 'LEMMA', line 136, column 4 to column 27)",
                                                      " (in 'LEMMA', line 137, column 4 to column 23)",
                                                      " (in 'LEMMA', line 139, column 6 to column 48)",
                                                      " (in 'LEMMA', line 138, column 33 to line 140, column 5)",
                                                      " (in 'LEMMA', line 138, column 4 to line 140, column 5)",
                                                      " (in 'LEMMA', line 143, column 4 to column 91)",
                                                      " (in 'LEMMA', line 145, column 6 to column 24)",
                                                      " (in 'LEMMA', line 149, column 8 to column 146)",
                                                      " (in 'LEMMA', line 146, column 31 to line 150, column 7)",
                                                      " (in 'LEMMA', line 146, column 6 to line 150, column 7)",
                                                      " (in 'LEMMA', line 144, column 21 to line 151, column 5)",
                                                      " (in 'LEMMA', line 144, column 4 to line 151, column 5)",
                                                      " (in 'LEMMA', line 153, column 6 to column 71)",
                                                      " (in 'LEMMA', line 154, column 6 to column 40)",
                                                      " (in 'LEMMA', line 155, column 6 to column 108)",
                                                      " (in 'LEMMA', line 156, column 6 to column 116)",
                                                      " (in 'LEMMA', line 157, column 29 to column 57)",
                                                      " (in 'LEMMA', line 157, column 6 to column 57)",
                                                      " (in 'LEMMA', line 158, column 6 to column 115)",
                                                      " (in 'LEMMA', line 159, column 6 to column 97)",
                                                      " (in 'LEMMA', line 161, column 6 to column 178)",
                                                      " (in 'LEMMA', line 162, column 6 to column 79)",
                                                      " (in 'LEMMA', line 163, column 6 to column 52)",
                                                      " (in 'LEMMA', line 164, column 6 to column 75)",
                                                      " (in 'LEMMA', line 165, column 6 to column 126)",
                                                      " (in 'LEMMA', line 166, column 6 to column 44)",
                                                      " (in 'LEMMA', line 167, column 6 to column 98)",
                                                      " (in 'LEMMA', line 168, column 6 to column 70)",
                                                      " (in 'LEMMA', line 169, column 6 to column 83)",
                                                      " (in 'LEMMA', line 170, column 6 to column 152)",
                                                      " (in 'LEMMA', line 171, column 6 to column 74)",
                                                      " (in 'LEMMA', line 172, column 6 to column 102)",
                                                      " (in 'LEMMA', line 173, column 6 to column 61)",
                                                      " (in 'LEMMA', line 175, column 8 to column 31)",
                                                      " (in 'LEMMA', line 176, column 8 to column 116)",
                                                      " (in 'LEMMA', line 177, column 8 to column 41)",
                                                      " (in 'LEMMA', line 174, column 37 to line 178, column 7)",
                                                      " (in 'LEMMA', line 174, column 6 to line 178, column 7)",
                                                      " (in 'LEMMA', line 186, column 8 to column 68)",
                                                      " (in 'LEMMA', line 185, column 47 to line 188, column 7)",
                                                      " (in 'LEMMA', line 185, column 6 to line 188, column 7)",
                                                      " (in 'LEMMA', line 152, column 22 to line 189, column 5)",
                                                      " (in 'LEMMA', line 152, column 4 to line 189, column 5)",
                                                      " (in 'LEMMA', line 191, column 4 to column 103)",
                                                      " (in 'LEMMA', line 192, column 4 to column 68)",
                                                      " (in 'LEMMA', line 106, column 2 to line 193, column 3)",
                                                      " (in 'LEMMA', line 227, column 2 to column 55)",
                                                      " (in 'LEMMA', line 228, column 2 to column 25)",
                                                      " (in 'LEMMA', line 235, column 6 to column 51)",
                                                      " (in 'LEMMA', line 234, column 11 to line 236, column 5)",
                                                      " (in 'LEMMA', line 232, column 8 to column 102)",
                                                      " (in 'LEMMA', line 231, column 23 to line 233, column 7)",
                                                      " (in 'LEMMA', line 231, column 6 to line 233, column 7)",
                                                      " (in 'LEMMA', line 230, column 25 to line 234, column 5)",
                                                      " (in 'LEMMA', line 230, column 4 to line 236, column 5)",
                                                      " (in 'LEMMA', line 229, column 30 to line 237, column 3)",
                                                      " (in 'LEMMA', line 229, column 2 to line 237, column 3)",
                                                      " (in 'LEMMA', line 239, column 4 to column 22)",
                                                      " (in 'LEMMA', line 242, column 6 to column 62)",
                                                      " (in 'LEMMA', line 241, column 21 to line 243, column 5)",
                                                      " (in 'LEMMA', line 241, column 4 to line 243, column 5)",
                                                      " (in 'LEMMA', line 238, column 2 to line 244, column 3)",
                                                      " (in 'LEMMA', line 201, column 2 to column 70)",
                                                      " (in 'LEMMA', line 202, column 2 to column 76)",
                                                      " (in 'LEMMA', line 203, column 2 to column 76)",
                                                      " (in 'LEMMA', line 204, column 2 to column 76)",
                                                      " (in 'LEMMA', line 205, column 2 to column 112)",
                                                      " (in 'LEMMA', line 207, column 4 to column 86)",
                                                      " (in 'LEMMA', line 206, column 27 to line 208, column 3)",
                                                      " (in 'LEMMA', line 206, column 2 to line 208, column 3)",
                                                      " (in 'LEMMA', line 209, column 2 to column 58)",
                                                      " (in 'LEMMA', line 210, column 2 to column 49)",
                                                      " (in 'LEMMA', line 211, column 2 to column 97)",
                                                      " (in 'LEMMA', line 212, column 2 to column 55)",
                                                      " (in 'LEMMA', line 213, column 2 to column 55)",
                                                      " (in 'LEMMA', line 214, column 2 to column 58)",
                                                      " (in 'LEMMA', line 215, column 2 to column 58)",
                                                      " (in 'LEMMA', line 218, column 2 to column 45)",
                                                      " (in 'LEMMA', line 222, column 6 to column 109)",
                                                      " (in 'LEMMA', line 221, column 25 to line 223, column 5)",
                                                      " (in 'LEMMA', line 221, column 4 to line 223, column 5)",
                                                      " (in 'LEMMA', line 220, column 30 to line 224, column 3)",
                                                      " (in 'LEMMA', line 220, column 2 to line 224, column 3)",
                                                      " (in 'LEMMA', line 10, column 2 to column 26)",
                                                      " (in 'LEMMA', line 11, column 20 to column 30)",
                                                      " (in 'LEMMA', line 11, column 2 to column 32)",
                                                      " (in 'LEMMA', line 12, column 2 to column 25)",
                                                      " (in 'LEMMA', line 13, column 21 to column 31)",
                                                      " (in 'LEMMA', line 13, column 33 to column 41)",
                                                      " (in 'LEMMA', line 13, column 2 to column 43)",
                                                      " (in 'LEMMA', line 14, column 21 to column 31)",
                                                      " (in 'LEMMA', line 14, column 33 to column 41)",
                                                      " (in 'LEMMA', line 14, column 2 to column 52)",
                                                      " (in 'LEMMA', line 15, column 2 to column 18)",
                                                      " (in 'LEMMA', line 16, column 2 to column 23)",
                                                      " (in 'LEMMA', line 19, column 2 to column 37)",
                                                      " (in 'LEMMA', line 20, column 2 to column 40)",
                                                      " (in 'LEMMA', line 21, column 2 to column 39)",
                                                      " (in 'LEMMA', line 22, column 2 to column 42)",
                                                      " (in 'LEMMA', line 23, column 2 to column 39)",
                                                      " (in 'LEMMA', line 24, column 2 to column 42)",
                                                      " (in 'LEMMA', line 25, column 2 to column 39)",
                                                      " (in 'LEMMA', line 26, column 2 to column 42)",
                                                      " (in 'LEMMA', line 27, column 2 to column 33)",
                                                      " (in 'LEMMA', line 28, column 2 to column 36)",
                                                      " (in 'LEMMA', line 29, column 2 to column 32)",
                                                      " (in 'LEMMA', line 30, column 2 to column 35)",
                                                      " (in 'LEMMA', line 31, column 2 to column 30)",
                                                      " (in 'LEMMA', line 32, column 2 to column 33)",
                                                      " (in 'LEMMA', line 33, column 2 to column 46)",
                                                      " (in 'LEMMA', line 34, column 2 to column 49)",
                                                      " (in 'LEMMA', line 35, column 2 to column 32)",
                                                      " (in 'LEMMA', line 36, column 2 to column 35)",
                                                      " (in 'LEMMA', line 37, column 2 to column 33)",
                                                      " (in 'LEMMA', line 38, column 2 to column 36)",
                                                      " (in 'LEMMA', line 39, column 2 to column 51)",
                                                      " (in 'LEMMA', line 40, column 2 to column 54)",
                                                      " (in 'LEMMA', line 41, column 2 to column 42)",
                                                      " (in 'LEMMA', line 42, column 36 to column 46)",
                                                      " (in 'LEMMA', line 42, column 2 to column 48)",
                                                      " (in 'LEMMA', line 43, column 2 to column 34)",
                                                      " (in 'LEMMA', line 44, column 2 to column 31)",
                                                      " (in 'LEMMA', line 45, column 2 to column 37)",
                                                      " (in 'LEMMA', line 46, column 2 to column 50)",
                                                      " (in 'LEMMA', line 47, column 31 to column 33)",
                                                      " (in 'LEMMA', line 47, column 2 to column 35)",
                                                      " (in 'LEMMA', line 48, column 2 to column 39)",
                                                      " (in 'LEMMA', line 49, column 2 to column 52)",
                                                      " (in 'LEMMA', line 50, column 2 to column 42)",
                                                      " (in 'LEMMA', line 51, column 2 to column 46)",
                                                      " (in 'LEMMA', line 52, column 2 to column 36)",
                                                      " (in 'LEMMA', line 53, column 2 to column 36)",
                                                      " (in 'LEMMA', line 54, column 2 to column 33)",
                                                      " (in 'LEMMA', line 55, column 2 to column 22)",
                                                      " (in 'LEMMA', line 56, column 26 to column 32)",
                                                      " (in 'LEMMA', line 56, column 2 to column 34)",
                                                      " (in 'LEMMA', line 57, column 28 to column 34)",
                                                      " (in 'LEMMA', line 57, column 2 to column 36)",
                                                      " (in 'LEMMA', line 58, column 32 to column 38)",
                                                      " (in 'LEMMA', line 58, column 2 to column 40)",
                                                      " (in 'LEMMA', line 59, column 35 to column 41)",
                                                      " (in 'LEMMA', line 59, column 2 to column 43)",
                                                      " (in 'LEMMA', line 60, column 33 to column 39)",
                                                      " (in 'LEMMA', line 60, column 2 to column 41)",
                                                      " (in 'LEMMA', line 64, column 2 to column 12)",
                                                      " (in 'LEMMA', line 65, column 2 to column 12)",
                                                      " (in 'LEMMA', line 66, column 2 to column 16)",
                                                      " (in 'LEMMA', line 67, column 2 to column 16)",
                                                      " (in 'LEMMA', line 68, column 2 to column 16)",
                                                      " (in 'LEMMA', line 69, column 2 to column 12)",
                                                      " (in 'LEMMA', line 70, column 2 to column 16)",
                                                      " (in 'LEMMA', line 71, column 2 to column 24)",
                                                      " (in 'LEMMA', line 72, column 2 to column 26)",
                                                      " (in 'LEMMA', line 73, column 2 to column 20)",
                                                      " (in 'LEMMA', line 83, column 28 to column 38)",
                                                      " (in 'LEMMA', line 92, column 45 to column 51)",
                                                      " (in 'LEMMA', line 95, column 20 to column 33)",
                                                      " (in 'LEMMA', line 95, column 34 to column 36)",
                                                      " (in 'LEMMA', line 96, column 20 to column 30)",
                                                      " (in 'LEMMA', line 96, column 31 to column 33)",
                                                      " (in 'LEMMA', line 97, column 24 to column 26)",
                                                      " (in 'LEMMA', line 98, column 24 to column 26)",
                                                      " (in 'LEMMA', line 99, column 23 to column 25)",
                                                      " (in 'LEMMA', line 227, column 20 to column 30)",
                                                      " (in 'LEMMA', line 227, column 31 to column 33)",
                                                      " (in 'LEMMA', line 228, column 21 to column 23)"};
#include <stan_meta_header.hpp>
class model_LEMMA final : public model_base_crtp<model_LEMMA> {
private:
  int nobs_types;
  std::vector<int> nobs;
  int nobs_max;
  std::vector<std::vector<int>> tobs;
  Eigen::Matrix<double, -1, -1> obs_data;
  int nt;
  double npop;
  double mu_duration_latent;
  double sigma_duration_latent;
  double mu_duration_rec_mild;
  double sigma_duration_rec_mild;
  double mu_duration_pre_hosp;
  double sigma_duration_pre_hosp;
  double mu_duration_hosp_mod;
  double sigma_duration_hosp_mod;
  double mu_frac_tested;
  double sigma_frac_tested;
  double mu_test_delay;
  double sigma_test_delay;
  double mu_severity;
  double sigma_severity;
  double mu_omicron_trans_multiplier;
  double sigma_omicron_trans_multiplier;
  double mu_hosp_delta;
  double sigma_hosp_delta;
  double mu_cases_delta;
  double sigma_cases_delta;
  double mu_duration_protection_infection;
  double sigma_duration_protection_infection;
  double lambda_initial_infected;
  std::vector<double> sigma_obs_est_inv;
  double frac_hosp_lemma;
  double VE_infection;
  double VE_infection_delta;
  double omicron_recovered_booster_scale;
  std::vector<double> num_boosters;
  double booster_VE_infection;
  double booster_VE_severe_given_infection;
  double frac_incidental_omicron;
  double VE_severe_given_infection_0;
  double hosp_frac_delta_0;
  double case_frac_delta_0;
  double omicron_growth;
  int ninter;
  std::vector<double> t_inter;
  std::vector<double> len_inter;
  std::vector<double> mu_beta_inter;
  std::vector<double> sigma_beta_inter;
  std::vector<double> lbd_beta_inter;
  int S;
  int E;
  int Imild;
  int Ipreh;
  int Hmod;
  int P;
  int Rlive;
  int ncompartments;
  int obs_hosp_census;
  int obs_cases;
 
public:
  ~model_LEMMA() { }
  
  inline std::string model_name() const final { return "model_LEMMA"; }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.26.1-1-g67504470", "stancflags = "};
  }
  
  
  model_LEMMA(stan::io::var_context& context__,
              unsigned int random_seed__ = 0,
              std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "model_LEMMA_namespace::model_LEMMA";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 138;
      context__.validate_dims("data initialization","nobs_types","int",
          context__.to_vec());
      nobs_types = std::numeric_limits<int>::min();
      
      current_statement__ = 138;
      nobs_types = context__.vals_i("nobs_types")[(1 - 1)];
      current_statement__ = 138;
      current_statement__ = 138;
      check_greater_or_equal(function__, "nobs_types", nobs_types, 0);
      current_statement__ = 139;
      validate_non_negative_index("nobs", "nobs_types", nobs_types);
      current_statement__ = 140;
      context__.validate_dims("data initialization","nobs","int",
          context__.to_vec(nobs_types));
      nobs = std::vector<int>(nobs_types, std::numeric_limits<int>::min());
      
      current_statement__ = 140;
      assign(nobs, nil_index_list(), context__.vals_i("nobs"),
        "assigning variable nobs");
      current_statement__ = 140;
      for (int sym1__ = 1; sym1__ <= nobs_types; ++sym1__) {
        current_statement__ = 140;
        current_statement__ = 140;
        check_greater_or_equal(function__, "nobs[sym1__]",
                               nobs[(sym1__ - 1)], 0);}
      current_statement__ = 141;
      context__.validate_dims("data initialization","nobs_max","int",
          context__.to_vec());
      nobs_max = std::numeric_limits<int>::min();
      
      current_statement__ = 141;
      nobs_max = context__.vals_i("nobs_max")[(1 - 1)];
      current_statement__ = 141;
      current_statement__ = 141;
      check_greater_or_equal(function__, "nobs_max", nobs_max, 0);
      current_statement__ = 142;
      validate_non_negative_index("tobs", "nobs_types", nobs_types);
      current_statement__ = 143;
      validate_non_negative_index("tobs", "nobs_max", nobs_max);
      current_statement__ = 144;
      context__.validate_dims("data initialization","tobs","int",
          context__.to_vec(nobs_types, nobs_max));
      tobs = std::vector<std::vector<int>>(nobs_types, std::vector<int>(nobs_max, std::numeric_limits<int>::min()));
      
      {
        std::vector<int> tobs_flat__;
        current_statement__ = 144;
        assign(tobs_flat__, nil_index_list(), context__.vals_i("tobs"),
          "assigning variable tobs_flat__");
        current_statement__ = 144;
        pos__ = 1;
        current_statement__ = 144;
        for (int sym1__ = 1; sym1__ <= nobs_max; ++sym1__) {
          current_statement__ = 144;
          for (int sym2__ = 1; sym2__ <= nobs_types; ++sym2__) {
            current_statement__ = 144;
            assign(tobs,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              tobs_flat__[(pos__ - 1)], "assigning variable tobs");
            current_statement__ = 144;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 144;
      for (int sym1__ = 1; sym1__ <= nobs_types; ++sym1__) {
        current_statement__ = 144;
        for (int sym2__ = 1; sym2__ <= nobs_max; ++sym2__) {
          current_statement__ = 144;
          current_statement__ = 144;
          check_greater_or_equal(function__, "tobs[sym1__, sym2__]",
                                 tobs[(sym1__ - 1)][(sym2__ - 1)], -1);}}
      current_statement__ = 145;
      validate_non_negative_index("obs_data", "nobs_types", nobs_types);
      current_statement__ = 146;
      validate_non_negative_index("obs_data", "nobs_max", nobs_max);
      current_statement__ = 147;
      context__.validate_dims("data initialization","obs_data","double",
          context__.to_vec(nobs_types, nobs_max));
      obs_data = Eigen::Matrix<double, -1, -1>(nobs_types, nobs_max);
      stan::math::fill(obs_data, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> obs_data_flat__;
        current_statement__ = 147;
        assign(obs_data_flat__, nil_index_list(),
          context__.vals_r("obs_data"), "assigning variable obs_data_flat__");
        current_statement__ = 147;
        pos__ = 1;
        current_statement__ = 147;
        for (int sym1__ = 1; sym1__ <= nobs_max; ++sym1__) {
          current_statement__ = 147;
          for (int sym2__ = 1; sym2__ <= nobs_types; ++sym2__) {
            current_statement__ = 147;
            assign(obs_data,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              obs_data_flat__[(pos__ - 1)], "assigning variable obs_data");
            current_statement__ = 147;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 147;
      for (int sym1__ = 1; sym1__ <= nobs_types; ++sym1__) {
        current_statement__ = 147;
        for (int sym2__ = 1; sym2__ <= nobs_max; ++sym2__) {
          current_statement__ = 147;
          current_statement__ = 147;
          check_greater_or_equal(function__, "obs_data[sym1__, sym2__]",
                                 rvalue(obs_data,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "obs_data"), 
                                 -1.0);}}
      current_statement__ = 148;
      context__.validate_dims("data initialization","nt","int",
          context__.to_vec());
      nt = std::numeric_limits<int>::min();
      
      current_statement__ = 148;
      nt = context__.vals_i("nt")[(1 - 1)];
      current_statement__ = 148;
      current_statement__ = 148;
      check_greater_or_equal(function__, "nt", nt, 0);
      current_statement__ = 149;
      context__.validate_dims("data initialization","npop","double",
          context__.to_vec());
      npop = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 149;
      npop = context__.vals_r("npop")[(1 - 1)];
      current_statement__ = 149;
      current_statement__ = 149;
      check_greater_or_equal(function__, "npop", npop, 0.0);
      current_statement__ = 150;
      context__.validate_dims("data initialization","mu_duration_latent",
          "double",context__.to_vec());
      mu_duration_latent = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 150;
      mu_duration_latent = context__.vals_r("mu_duration_latent")[(1 - 1)];
      current_statement__ = 150;
      current_statement__ = 150;
      check_greater_or_equal(function__, "mu_duration_latent",
                             mu_duration_latent, 1.0);
      current_statement__ = 151;
      context__.validate_dims("data initialization","sigma_duration_latent",
          "double",context__.to_vec());
      sigma_duration_latent = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 151;
      sigma_duration_latent = context__.vals_r("sigma_duration_latent")[
          (1 - 1)];
      current_statement__ = 151;
      current_statement__ = 151;
      check_greater_or_equal(function__, "sigma_duration_latent",
                             sigma_duration_latent, 0.0);
      current_statement__ = 152;
      context__.validate_dims("data initialization","mu_duration_rec_mild",
          "double",context__.to_vec());
      mu_duration_rec_mild = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 152;
      mu_duration_rec_mild = context__.vals_r("mu_duration_rec_mild")[
          (1 - 1)];
      current_statement__ = 152;
      current_statement__ = 152;
      check_greater_or_equal(function__, "mu_duration_rec_mild",
                             mu_duration_rec_mild, 1.0);
      current_statement__ = 153;
      context__.validate_dims("data initialization",
          "sigma_duration_rec_mild","double",context__.to_vec());
      sigma_duration_rec_mild = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 153;
      sigma_duration_rec_mild = context__.vals_r("sigma_duration_rec_mild")[
          (1 - 1)];
      current_statement__ = 153;
      current_statement__ = 153;
      check_greater_or_equal(function__, "sigma_duration_rec_mild",
                             sigma_duration_rec_mild, 0.0);
      current_statement__ = 154;
      context__.validate_dims("data initialization","mu_duration_pre_hosp",
          "double",context__.to_vec());
      mu_duration_pre_hosp = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 154;
      mu_duration_pre_hosp = context__.vals_r("mu_duration_pre_hosp")[
          (1 - 1)];
      current_statement__ = 154;
      current_statement__ = 154;
      check_greater_or_equal(function__, "mu_duration_pre_hosp",
                             mu_duration_pre_hosp, 1.0);
      current_statement__ = 155;
      context__.validate_dims("data initialization",
          "sigma_duration_pre_hosp","double",context__.to_vec());
      sigma_duration_pre_hosp = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 155;
      sigma_duration_pre_hosp = context__.vals_r("sigma_duration_pre_hosp")[
          (1 - 1)];
      current_statement__ = 155;
      current_statement__ = 155;
      check_greater_or_equal(function__, "sigma_duration_pre_hosp",
                             sigma_duration_pre_hosp, 0.0);
      current_statement__ = 156;
      context__.validate_dims("data initialization","mu_duration_hosp_mod",
          "double",context__.to_vec());
      mu_duration_hosp_mod = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 156;
      mu_duration_hosp_mod = context__.vals_r("mu_duration_hosp_mod")[
          (1 - 1)];
      current_statement__ = 156;
      current_statement__ = 156;
      check_greater_or_equal(function__, "mu_duration_hosp_mod",
                             mu_duration_hosp_mod, 1.0);
      current_statement__ = 157;
      context__.validate_dims("data initialization",
          "sigma_duration_hosp_mod","double",context__.to_vec());
      sigma_duration_hosp_mod = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 157;
      sigma_duration_hosp_mod = context__.vals_r("sigma_duration_hosp_mod")[
          (1 - 1)];
      current_statement__ = 157;
      current_statement__ = 157;
      check_greater_or_equal(function__, "sigma_duration_hosp_mod",
                             sigma_duration_hosp_mod, 0.0);
      current_statement__ = 158;
      context__.validate_dims("data initialization","mu_frac_tested",
          "double",context__.to_vec());
      mu_frac_tested = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 158;
      mu_frac_tested = context__.vals_r("mu_frac_tested")[(1 - 1)];
      current_statement__ = 158;
      current_statement__ = 158;
      check_greater_or_equal(function__, "mu_frac_tested", mu_frac_tested,
                             0.0);
      current_statement__ = 159;
      context__.validate_dims("data initialization","sigma_frac_tested",
          "double",context__.to_vec());
      sigma_frac_tested = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 159;
      sigma_frac_tested = context__.vals_r("sigma_frac_tested")[(1 - 1)];
      current_statement__ = 159;
      current_statement__ = 159;
      check_greater_or_equal(function__, "sigma_frac_tested",
                             sigma_frac_tested, 0.0);
      current_statement__ = 160;
      context__.validate_dims("data initialization","mu_test_delay","double",
          context__.to_vec());
      mu_test_delay = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 160;
      mu_test_delay = context__.vals_r("mu_test_delay")[(1 - 1)];
      current_statement__ = 160;
      current_statement__ = 160;
      check_greater_or_equal(function__, "mu_test_delay", mu_test_delay, 0.0);
      current_statement__ = 161;
      context__.validate_dims("data initialization","sigma_test_delay",
          "double",context__.to_vec());
      sigma_test_delay = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 161;
      sigma_test_delay = context__.vals_r("sigma_test_delay")[(1 - 1)];
      current_statement__ = 161;
      current_statement__ = 161;
      check_greater_or_equal(function__, "sigma_test_delay",
                             sigma_test_delay, 0.0);
      current_statement__ = 162;
      context__.validate_dims("data initialization","mu_severity","double",
          context__.to_vec());
      mu_severity = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 162;
      mu_severity = context__.vals_r("mu_severity")[(1 - 1)];
      current_statement__ = 162;
      current_statement__ = 162;
      check_greater_or_equal(function__, "mu_severity", mu_severity, 0.0);
      current_statement__ = 163;
      context__.validate_dims("data initialization","sigma_severity",
          "double",context__.to_vec());
      sigma_severity = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 163;
      sigma_severity = context__.vals_r("sigma_severity")[(1 - 1)];
      current_statement__ = 163;
      current_statement__ = 163;
      check_greater_or_equal(function__, "sigma_severity", sigma_severity,
                             0.0);
      current_statement__ = 164;
      context__.validate_dims("data initialization",
          "mu_omicron_trans_multiplier","double",context__.to_vec());
      mu_omicron_trans_multiplier = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 164;
      mu_omicron_trans_multiplier = context__.vals_r("mu_omicron_trans_multiplier")[
          (1 - 1)];
      current_statement__ = 164;
      current_statement__ = 164;
      check_greater_or_equal(function__, "mu_omicron_trans_multiplier",
                             mu_omicron_trans_multiplier, 0.0);
      current_statement__ = 165;
      context__.validate_dims("data initialization",
          "sigma_omicron_trans_multiplier","double",context__.to_vec());
      sigma_omicron_trans_multiplier = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 165;
      sigma_omicron_trans_multiplier = context__.vals_r("sigma_omicron_trans_multiplier")[
          (1 - 1)];
      current_statement__ = 165;
      current_statement__ = 165;
      check_greater_or_equal(function__, "sigma_omicron_trans_multiplier",
                             sigma_omicron_trans_multiplier, 0.0);
      current_statement__ = 166;
      context__.validate_dims("data initialization","mu_hosp_delta","double",
          context__.to_vec());
      mu_hosp_delta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 166;
      mu_hosp_delta = context__.vals_r("mu_hosp_delta")[(1 - 1)];
      current_statement__ = 166;
      current_statement__ = 166;
      check_greater_or_equal(function__, "mu_hosp_delta", mu_hosp_delta, 0.0);
      current_statement__ = 167;
      context__.validate_dims("data initialization","sigma_hosp_delta",
          "double",context__.to_vec());
      sigma_hosp_delta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 167;
      sigma_hosp_delta = context__.vals_r("sigma_hosp_delta")[(1 - 1)];
      current_statement__ = 167;
      current_statement__ = 167;
      check_greater_or_equal(function__, "sigma_hosp_delta",
                             sigma_hosp_delta, 0.0);
      current_statement__ = 168;
      context__.validate_dims("data initialization","mu_cases_delta",
          "double",context__.to_vec());
      mu_cases_delta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 168;
      mu_cases_delta = context__.vals_r("mu_cases_delta")[(1 - 1)];
      current_statement__ = 168;
      current_statement__ = 168;
      check_greater_or_equal(function__, "mu_cases_delta", mu_cases_delta,
                             0.0);
      current_statement__ = 169;
      context__.validate_dims("data initialization","sigma_cases_delta",
          "double",context__.to_vec());
      sigma_cases_delta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 169;
      sigma_cases_delta = context__.vals_r("sigma_cases_delta")[(1 - 1)];
      current_statement__ = 169;
      current_statement__ = 169;
      check_greater_or_equal(function__, "sigma_cases_delta",
                             sigma_cases_delta, 0.0);
      current_statement__ = 170;
      context__.validate_dims("data initialization",
          "mu_duration_protection_infection","double",context__.to_vec());
      mu_duration_protection_infection = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 170;
      mu_duration_protection_infection = context__.vals_r("mu_duration_protection_infection")[
          (1 - 1)];
      current_statement__ = 170;
      current_statement__ = 170;
      check_greater_or_equal(function__, "mu_duration_protection_infection",
                             mu_duration_protection_infection, 0.0);
      current_statement__ = 171;
      context__.validate_dims("data initialization",
          "sigma_duration_protection_infection","double",context__.to_vec());
      sigma_duration_protection_infection = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 171;
      sigma_duration_protection_infection = context__.vals_r("sigma_duration_protection_infection")[
          (1 - 1)];
      current_statement__ = 171;
      current_statement__ = 171;
      check_greater_or_equal(function__,
                             "sigma_duration_protection_infection",
                             sigma_duration_protection_infection, 0.0);
      current_statement__ = 172;
      context__.validate_dims("data initialization",
          "lambda_initial_infected","double",context__.to_vec());
      lambda_initial_infected = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 172;
      lambda_initial_infected = context__.vals_r("lambda_initial_infected")[
          (1 - 1)];
      current_statement__ = 172;
      current_statement__ = 172;
      check_greater_or_equal(function__, "lambda_initial_infected",
                             lambda_initial_infected, 0.0);
      current_statement__ = 173;
      validate_non_negative_index("sigma_obs_est_inv", "nobs_types",
                                  nobs_types);
      current_statement__ = 174;
      context__.validate_dims("data initialization","sigma_obs_est_inv",
          "double",context__.to_vec(nobs_types));
      sigma_obs_est_inv = std::vector<double>(nobs_types, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 174;
      assign(sigma_obs_est_inv, nil_index_list(),
        context__.vals_r("sigma_obs_est_inv"),
        "assigning variable sigma_obs_est_inv");
      current_statement__ = 174;
      for (int sym1__ = 1; sym1__ <= nobs_types; ++sym1__) {
        current_statement__ = 174;
        current_statement__ = 174;
        check_greater_or_equal(function__, "sigma_obs_est_inv[sym1__]",
                               sigma_obs_est_inv[(sym1__ - 1)], 0.0);}
      current_statement__ = 175;
      context__.validate_dims("data initialization","frac_hosp_lemma",
          "double",context__.to_vec());
      frac_hosp_lemma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 175;
      frac_hosp_lemma = context__.vals_r("frac_hosp_lemma")[(1 - 1)];
      current_statement__ = 175;
      current_statement__ = 175;
      check_greater_or_equal(function__, "frac_hosp_lemma", frac_hosp_lemma,
                             0.0);
      current_statement__ = 176;
      context__.validate_dims("data initialization","VE_infection","double",
          context__.to_vec());
      VE_infection = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 176;
      VE_infection = context__.vals_r("VE_infection")[(1 - 1)];
      current_statement__ = 176;
      current_statement__ = 176;
      check_greater_or_equal(function__, "VE_infection", VE_infection, 0.0);
      current_statement__ = 177;
      context__.validate_dims("data initialization","VE_infection_delta",
          "double",context__.to_vec());
      VE_infection_delta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 177;
      VE_infection_delta = context__.vals_r("VE_infection_delta")[(1 - 1)];
      current_statement__ = 177;
      current_statement__ = 177;
      check_greater_or_equal(function__, "VE_infection_delta",
                             VE_infection_delta, 0.0);
      current_statement__ = 178;
      context__.validate_dims("data initialization",
          "omicron_recovered_booster_scale","double",context__.to_vec());
      omicron_recovered_booster_scale = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 178;
      omicron_recovered_booster_scale = context__.vals_r("omicron_recovered_booster_scale")[
          (1 - 1)];
      current_statement__ = 178;
      current_statement__ = 178;
      check_greater_or_equal(function__, "omicron_recovered_booster_scale",
                             omicron_recovered_booster_scale, 0.0);
      current_statement__ = 179;
      validate_non_negative_index("num_boosters", "nt", nt);
      current_statement__ = 180;
      context__.validate_dims("data initialization","num_boosters","double",
          context__.to_vec(nt));
      num_boosters = std::vector<double>(nt, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 180;
      assign(num_boosters, nil_index_list(),
        context__.vals_r("num_boosters"), "assigning variable num_boosters");
      current_statement__ = 180;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 180;
        current_statement__ = 180;
        check_greater_or_equal(function__, "num_boosters[sym1__]",
                               num_boosters[(sym1__ - 1)], 0.0);}
      current_statement__ = 181;
      context__.validate_dims("data initialization","booster_VE_infection",
          "double",context__.to_vec());
      booster_VE_infection = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 181;
      booster_VE_infection = context__.vals_r("booster_VE_infection")[
          (1 - 1)];
      current_statement__ = 181;
      current_statement__ = 181;
      check_greater_or_equal(function__, "booster_VE_infection",
                             booster_VE_infection, 0.0);
      current_statement__ = 182;
      context__.validate_dims("data initialization",
          "booster_VE_severe_given_infection","double",context__.to_vec());
      booster_VE_severe_given_infection = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 182;
      booster_VE_severe_given_infection = context__.vals_r("booster_VE_severe_given_infection")[
          (1 - 1)];
      current_statement__ = 182;
      current_statement__ = 182;
      check_greater_or_equal(function__, "booster_VE_severe_given_infection",
                             booster_VE_severe_given_infection, 0.0);
      current_statement__ = 183;
      context__.validate_dims("data initialization",
          "frac_incidental_omicron","double",context__.to_vec());
      frac_incidental_omicron = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 183;
      frac_incidental_omicron = context__.vals_r("frac_incidental_omicron")[
          (1 - 1)];
      current_statement__ = 183;
      current_statement__ = 183;
      check_greater_or_equal(function__, "frac_incidental_omicron",
                             frac_incidental_omicron, 0.0);
      current_statement__ = 184;
      context__.validate_dims("data initialization",
          "VE_severe_given_infection_0","double",context__.to_vec());
      VE_severe_given_infection_0 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 184;
      VE_severe_given_infection_0 = context__.vals_r("VE_severe_given_infection_0")[
          (1 - 1)];
      current_statement__ = 184;
      current_statement__ = 184;
      check_greater_or_equal(function__, "VE_severe_given_infection_0",
                             VE_severe_given_infection_0, 0.0);
      current_statement__ = 185;
      context__.validate_dims("data initialization","hosp_frac_delta_0",
          "double",context__.to_vec());
      hosp_frac_delta_0 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 185;
      hosp_frac_delta_0 = context__.vals_r("hosp_frac_delta_0")[(1 - 1)];
      current_statement__ = 185;
      current_statement__ = 185;
      check_greater_or_equal(function__, "hosp_frac_delta_0",
                             hosp_frac_delta_0, 0.0);
      current_statement__ = 186;
      context__.validate_dims("data initialization","case_frac_delta_0",
          "double",context__.to_vec());
      case_frac_delta_0 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 186;
      case_frac_delta_0 = context__.vals_r("case_frac_delta_0")[(1 - 1)];
      current_statement__ = 186;
      current_statement__ = 186;
      check_greater_or_equal(function__, "case_frac_delta_0",
                             case_frac_delta_0, 0.0);
      current_statement__ = 187;
      context__.validate_dims("data initialization","omicron_growth",
          "double",context__.to_vec());
      omicron_growth = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 187;
      omicron_growth = context__.vals_r("omicron_growth")[(1 - 1)];
      current_statement__ = 187;
      current_statement__ = 187;
      check_greater_or_equal(function__, "omicron_growth", omicron_growth,
                             0.0);
      current_statement__ = 188;
      context__.validate_dims("data initialization","ninter","int",
          context__.to_vec());
      ninter = std::numeric_limits<int>::min();
      
      current_statement__ = 188;
      ninter = context__.vals_i("ninter")[(1 - 1)];
      current_statement__ = 188;
      current_statement__ = 188;
      check_greater_or_equal(function__, "ninter", ninter, 0);
      current_statement__ = 189;
      validate_non_negative_index("t_inter", "ninter", ninter);
      current_statement__ = 190;
      context__.validate_dims("data initialization","t_inter","double",
          context__.to_vec(ninter));
      t_inter = std::vector<double>(ninter, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 190;
      assign(t_inter, nil_index_list(), context__.vals_r("t_inter"),
        "assigning variable t_inter");
      current_statement__ = 190;
      for (int sym1__ = 1; sym1__ <= ninter; ++sym1__) {
        current_statement__ = 190;
        current_statement__ = 190;
        check_greater_or_equal(function__, "t_inter[sym1__]",
                               t_inter[(sym1__ - 1)], 1.0);}
      current_statement__ = 191;
      validate_non_negative_index("len_inter", "ninter", ninter);
      current_statement__ = 192;
      context__.validate_dims("data initialization","len_inter","double",
          context__.to_vec(ninter));
      len_inter = std::vector<double>(ninter, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 192;
      assign(len_inter, nil_index_list(), context__.vals_r("len_inter"),
        "assigning variable len_inter");
      current_statement__ = 192;
      for (int sym1__ = 1; sym1__ <= ninter; ++sym1__) {
        current_statement__ = 192;
        current_statement__ = 192;
        check_greater_or_equal(function__, "len_inter[sym1__]",
                               len_inter[(sym1__ - 1)], 1.0);}
      current_statement__ = 193;
      validate_non_negative_index("mu_beta_inter", "ninter", ninter);
      current_statement__ = 194;
      context__.validate_dims("data initialization","mu_beta_inter","double",
          context__.to_vec(ninter));
      mu_beta_inter = std::vector<double>(ninter, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 194;
      assign(mu_beta_inter, nil_index_list(),
        context__.vals_r("mu_beta_inter"), "assigning variable mu_beta_inter");
      current_statement__ = 194;
      for (int sym1__ = 1; sym1__ <= ninter; ++sym1__) {
        current_statement__ = 194;
        current_statement__ = 194;
        check_greater_or_equal(function__, "mu_beta_inter[sym1__]",
                               mu_beta_inter[(sym1__ - 1)], 0.0);}
      current_statement__ = 195;
      validate_non_negative_index("sigma_beta_inter", "ninter", ninter);
      current_statement__ = 196;
      context__.validate_dims("data initialization","sigma_beta_inter",
          "double",context__.to_vec(ninter));
      sigma_beta_inter = std::vector<double>(ninter, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 196;
      assign(sigma_beta_inter, nil_index_list(),
        context__.vals_r("sigma_beta_inter"),
        "assigning variable sigma_beta_inter");
      current_statement__ = 196;
      for (int sym1__ = 1; sym1__ <= ninter; ++sym1__) {
        current_statement__ = 196;
        current_statement__ = 196;
        check_greater_or_equal(function__, "sigma_beta_inter[sym1__]",
                               sigma_beta_inter[(sym1__ - 1)], 0.0);}
      current_statement__ = 197;
      validate_non_negative_index("lbd_beta_inter", "ninter", ninter);
      current_statement__ = 198;
      context__.validate_dims("data initialization","lbd_beta_inter",
          "double",context__.to_vec(ninter));
      lbd_beta_inter = std::vector<double>(ninter, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 198;
      assign(lbd_beta_inter, nil_index_list(),
        context__.vals_r("lbd_beta_inter"),
        "assigning variable lbd_beta_inter");
      current_statement__ = 198;
      for (int sym1__ = 1; sym1__ <= ninter; ++sym1__) {
        current_statement__ = 198;
        current_statement__ = 198;
        check_greater_or_equal(function__, "lbd_beta_inter[sym1__]",
                               lbd_beta_inter[(sym1__ - 1)], 0.0);}
      current_statement__ = 199;
      S = std::numeric_limits<int>::min();
      
      current_statement__ = 199;
      S = 1;
      current_statement__ = 200;
      E = std::numeric_limits<int>::min();
      
      current_statement__ = 200;
      E = 2;
      current_statement__ = 201;
      Imild = std::numeric_limits<int>::min();
      
      current_statement__ = 201;
      Imild = 3;
      current_statement__ = 202;
      Ipreh = std::numeric_limits<int>::min();
      
      current_statement__ = 202;
      Ipreh = 4;
      current_statement__ = 203;
      Hmod = std::numeric_limits<int>::min();
      
      current_statement__ = 203;
      Hmod = 5;
      current_statement__ = 204;
      P = std::numeric_limits<int>::min();
      
      current_statement__ = 204;
      P = 6;
      current_statement__ = 205;
      Rlive = std::numeric_limits<int>::min();
      
      current_statement__ = 205;
      Rlive = 7;
      current_statement__ = 206;
      ncompartments = std::numeric_limits<int>::min();
      
      current_statement__ = 206;
      ncompartments = 7;
      current_statement__ = 207;
      obs_hosp_census = std::numeric_limits<int>::min();
      
      current_statement__ = 207;
      obs_hosp_census = 1;
      current_statement__ = 208;
      obs_cases = std::numeric_limits<int>::min();
      
      current_statement__ = 208;
      obs_cases = 2;
      current_statement__ = 209;
      validate_non_negative_index("sigma_obs", "nobs_types", nobs_types);
      current_statement__ = 210;
      validate_non_negative_index("beta_multiplier", "ninter", ninter);
      current_statement__ = 211;
      validate_non_negative_index("x", "ncompartments", ncompartments);
      current_statement__ = 212;
      validate_non_negative_index("x", "nt", nt);
      current_statement__ = 213;
      validate_non_negative_index("sim_data", "nobs_types", nobs_types);
      current_statement__ = 214;
      validate_non_negative_index("sim_data", "nt", nt);
      current_statement__ = 215;
      validate_non_negative_index("new_cases", "nt", nt);
      current_statement__ = 216;
      validate_non_negative_index("soon_positive", "nt", nt);
      current_statement__ = 217;
      validate_non_negative_index("beta", "nt", nt);
      current_statement__ = 218;
      validate_non_negative_index("sim_data_with_error", "nobs_types",
                                  nobs_types);
      current_statement__ = 219;
      validate_non_negative_index("sim_data_with_error", "nt", nt);
      current_statement__ = 220;
      validate_non_negative_index("Rt", "nt", nt);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += nobs_types;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += ninter;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "model_LEMMA_namespace::log_prob";
(void) function__;  // suppress unused var warning
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      local_scalar_t__ duration_latent;
      duration_latent = DUMMY_VAR__;
      
      current_statement__ = 1;
      duration_latent = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        duration_latent = stan::math::lb_constrain(duration_latent, 1.0, lp__);
      } else {
        current_statement__ = 1;
        duration_latent = stan::math::lb_constrain(duration_latent, 1.0);
      }
      local_scalar_t__ duration_rec_mild;
      duration_rec_mild = DUMMY_VAR__;
      
      current_statement__ = 2;
      duration_rec_mild = in__.scalar();
      current_statement__ = 2;
      if (jacobian__) {
        current_statement__ = 2;
        duration_rec_mild = stan::math::lb_constrain(duration_rec_mild, 1.0,
                              lp__);
      } else {
        current_statement__ = 2;
        duration_rec_mild = stan::math::lb_constrain(duration_rec_mild, 1.0);
      }
      local_scalar_t__ duration_pre_hosp;
      duration_pre_hosp = DUMMY_VAR__;
      
      current_statement__ = 3;
      duration_pre_hosp = in__.scalar();
      current_statement__ = 3;
      if (jacobian__) {
        current_statement__ = 3;
        duration_pre_hosp = stan::math::lb_constrain(duration_pre_hosp, 1.0,
                              lp__);
      } else {
        current_statement__ = 3;
        duration_pre_hosp = stan::math::lb_constrain(duration_pre_hosp, 1.0);
      }
      local_scalar_t__ duration_hosp_mod;
      duration_hosp_mod = DUMMY_VAR__;
      
      current_statement__ = 4;
      duration_hosp_mod = in__.scalar();
      current_statement__ = 4;
      if (jacobian__) {
        current_statement__ = 4;
        duration_hosp_mod = stan::math::lb_constrain(duration_hosp_mod, 1.0,
                              lp__);
      } else {
        current_statement__ = 4;
        duration_hosp_mod = stan::math::lb_constrain(duration_hosp_mod, 1.0);
      }
      local_scalar_t__ duration_protection_infection;
      duration_protection_infection = DUMMY_VAR__;
      
      current_statement__ = 5;
      duration_protection_infection = in__.scalar();
      current_statement__ = 5;
      if (jacobian__) {
        current_statement__ = 5;
        duration_protection_infection = stan::math::lb_constrain(
                                          duration_protection_infection, 1.0,
                                          lp__);
      } else {
        current_statement__ = 5;
        duration_protection_infection = stan::math::lb_constrain(
                                          duration_protection_infection, 1.0);
      }
      local_scalar_t__ frac_tested;
      frac_tested = DUMMY_VAR__;
      
      current_statement__ = 6;
      frac_tested = in__.scalar();
      current_statement__ = 6;
      if (jacobian__) {
        current_statement__ = 6;
        frac_tested = stan::math::lub_constrain(frac_tested, 0.0, 1.0, lp__);
      } else {
        current_statement__ = 6;
        frac_tested = stan::math::lub_constrain(frac_tested, 0.0, 1.0);
      }
      local_scalar_t__ initial_infected;
      initial_infected = DUMMY_VAR__;
      
      current_statement__ = 7;
      initial_infected = in__.scalar();
      current_statement__ = 7;
      if (jacobian__) {
        current_statement__ = 7;
        initial_infected = stan::math::lb_constrain(initial_infected, 0.0,
                             lp__);
      } else {
        current_statement__ = 7;
        initial_infected = stan::math::lb_constrain(initial_infected, 0.0);
      }
      std::vector<local_scalar_t__> sigma_obs;
      sigma_obs = std::vector<local_scalar_t__>(nobs_types, DUMMY_VAR__);
      
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= nobs_types; ++sym1__) {
        current_statement__ = 8;
        assign(sigma_obs, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable sigma_obs");}
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= nobs_types; ++sym1__) {
        current_statement__ = 8;
        if (jacobian__) {
          current_statement__ = 8;
          assign(sigma_obs, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(sigma_obs[(sym1__ - 1)], 0.0, lp__),
            "assigning variable sigma_obs");
        } else {
          current_statement__ = 8;
          assign(sigma_obs, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(sigma_obs[(sym1__ - 1)], 0.0),
            "assigning variable sigma_obs");
        }}
      local_scalar_t__ severity;
      severity = DUMMY_VAR__;
      
      current_statement__ = 9;
      severity = in__.scalar();
      current_statement__ = 9;
      if (jacobian__) {
        current_statement__ = 9;
        severity = stan::math::lb_constrain(severity, 0.0, lp__);
      } else {
        current_statement__ = 9;
        severity = stan::math::lb_constrain(severity, 0.0);
      }
      local_scalar_t__ omicron_trans_multiplier;
      omicron_trans_multiplier = DUMMY_VAR__;
      
      current_statement__ = 10;
      omicron_trans_multiplier = in__.scalar();
      current_statement__ = 10;
      if (jacobian__) {
        current_statement__ = 10;
        omicron_trans_multiplier = stan::math::lb_constrain(
                                     omicron_trans_multiplier, 0.0, lp__);
      } else {
        current_statement__ = 10;
        omicron_trans_multiplier = stan::math::lb_constrain(
                                     omicron_trans_multiplier, 0.0);
      }
      local_scalar_t__ test_delay;
      test_delay = DUMMY_VAR__;
      
      current_statement__ = 11;
      test_delay = in__.scalar();
      current_statement__ = 11;
      if (jacobian__) {
        current_statement__ = 11;
        test_delay = stan::math::lb_constrain(test_delay, 1.0, lp__);
      } else {
        current_statement__ = 11;
        test_delay = stan::math::lb_constrain(test_delay, 1.0);
      }
      local_scalar_t__ hosp_delta;
      hosp_delta = DUMMY_VAR__;
      
      current_statement__ = 12;
      hosp_delta = in__.scalar();
      current_statement__ = 12;
      if (jacobian__) {
        current_statement__ = 12;
        hosp_delta = stan::math::lb_constrain(hosp_delta, 0.0, lp__);
      } else {
        current_statement__ = 12;
        hosp_delta = stan::math::lb_constrain(hosp_delta, 0.0);
      }
      local_scalar_t__ cases_delta;
      cases_delta = DUMMY_VAR__;
      
      current_statement__ = 13;
      cases_delta = in__.scalar();
      current_statement__ = 13;
      if (jacobian__) {
        current_statement__ = 13;
        cases_delta = stan::math::lb_constrain(cases_delta, 0.0, lp__);
      } else {
        current_statement__ = 13;
        cases_delta = stan::math::lb_constrain(cases_delta, 0.0);
      }
      std::vector<local_scalar_t__> beta_multiplier;
      beta_multiplier = std::vector<local_scalar_t__>(ninter, DUMMY_VAR__);
      
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= ninter; ++sym1__) {
        current_statement__ = 14;
        assign(beta_multiplier,
          cons_list(index_uni(sym1__), nil_index_list()), in__.scalar(),
          "assigning variable beta_multiplier");}
      current_statement__ = 14;
      check_matching_dims("constraint", "beta_multiplier", beta_multiplier,
                          "lower", lbd_beta_inter);
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= ninter; ++sym1__) {
        current_statement__ = 14;
        if (jacobian__) {
          current_statement__ = 14;
          assign(beta_multiplier,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(beta_multiplier[(sym1__ - 1)],
              lbd_beta_inter[(sym1__ - 1)], lp__),
            "assigning variable beta_multiplier");
        } else {
          current_statement__ = 14;
          assign(beta_multiplier,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(beta_multiplier[(sym1__ - 1)],
              lbd_beta_inter[(sym1__ - 1)]),
            "assigning variable beta_multiplier");
        }}
      Eigen::Matrix<local_scalar_t__, -1, -1> x;
      x = Eigen::Matrix<local_scalar_t__, -1, -1>(ncompartments, nt);
      stan::math::fill(x, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> sim_data;
      sim_data = Eigen::Matrix<local_scalar_t__, -1, -1>(nobs_types, nt);
      stan::math::fill(sim_data, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, 1, -1> new_cases;
      new_cases = Eigen::Matrix<local_scalar_t__, 1, -1>(nt);
      stan::math::fill(new_cases, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, 1, -1> soon_positive;
      soon_positive = Eigen::Matrix<local_scalar_t__, 1, -1>(nt);
      stan::math::fill(soon_positive, DUMMY_VAR__);
      
      std::vector<local_scalar_t__> beta;
      beta = std::vector<local_scalar_t__>(nt, DUMMY_VAR__);
      
      local_scalar_t__ frac_hosp_0;
      frac_hosp_0 = DUMMY_VAR__;
      
      current_statement__ = 25;
      for (int it = 1; it <= nt; ++it) {
        current_statement__ = 23;
        for (int itype = 1; itype <= nobs_types; ++itype) {
          current_statement__ = 21;
          assign(sim_data,
            cons_list(index_uni(itype),
              cons_list(index_uni(it), nil_index_list())), 0.0,
            "assigning variable sim_data");}}
      {
        local_scalar_t__ newE;
        newE = DUMMY_VAR__;
        
        local_scalar_t__ newI;
        newI = DUMMY_VAR__;
        
        local_scalar_t__ frac_init_E;
        frac_init_E = DUMMY_VAR__;
        
        local_scalar_t__ beta_0;
        beta_0 = DUMMY_VAR__;
        
        local_scalar_t__ frac_hosp;
        frac_hosp = DUMMY_VAR__;
        
        local_scalar_t__ frac_boosters_to_susceptible;
        frac_boosters_to_susceptible = DUMMY_VAR__;
        
        local_scalar_t__ new_protected;
        new_protected = DUMMY_VAR__;
        
        local_scalar_t__ increased_severity_protection;
        increased_severity_protection = DUMMY_VAR__;
        
        local_scalar_t__ frac_increased_severity_protection;
        frac_increased_severity_protection = DUMMY_VAR__;
        
        local_scalar_t__ new_admits;
        new_admits = DUMMY_VAR__;
        
        local_scalar_t__ VE_severe_given_infection;
        VE_severe_given_infection = DUMMY_VAR__;
        
        local_scalar_t__ lost_protection_infection;
        lost_protection_infection = DUMMY_VAR__;
        
        current_statement__ = 38;
        validate_non_negative_index("hosp_frac_delta", "nt", nt);
        Eigen::Matrix<local_scalar_t__, 1, -1> hosp_frac_delta;
        hosp_frac_delta = Eigen::Matrix<local_scalar_t__, 1, -1>(nt);
        stan::math::fill(hosp_frac_delta, DUMMY_VAR__);
        
        current_statement__ = 40;
        validate_non_negative_index("case_frac_delta", "nt", nt);
        Eigen::Matrix<local_scalar_t__, 1, -1> case_frac_delta;
        case_frac_delta = Eigen::Matrix<local_scalar_t__, 1, -1>(nt);
        stan::math::fill(case_frac_delta, DUMMY_VAR__);
        
        current_statement__ = 45;
        for (int it = 1; it <= nt; ++it) {
          current_statement__ = 42;
          assign(hosp_frac_delta, cons_list(index_uni(it), nil_index_list()),
            (1 /
              (1 +
                (hosp_frac_delta_0 * stan::math::exp((it * omicron_growth))))),
            "assigning variable hosp_frac_delta");
          current_statement__ = 43;
          assign(case_frac_delta, cons_list(index_uni(it), nil_index_list()),
            (1 /
              (1 +
                (case_frac_delta_0 * stan::math::exp((it * omicron_growth))))),
            "assigning variable case_frac_delta");}
        current_statement__ = 46;
        VE_severe_given_infection = VE_severe_given_infection_0;
        current_statement__ = 47;
        frac_hosp_0 = ((frac_hosp_lemma * (1 - VE_severe_given_infection)) *
                        severity);
        current_statement__ = 48;
        assign(x,
          cons_list(index_omni(), cons_list(index_uni(1), nil_index_list())),
          rep_vector(0.0, ncompartments), "assigning variable x");
        current_statement__ = 49;
        frac_init_E = (duration_latent /
                        (duration_latent + duration_rec_mild));
        current_statement__ = 50;
        assign(x,
          cons_list(index_uni(E), cons_list(index_uni(1), nil_index_list())),
          (frac_init_E * initial_infected), "assigning variable x");
        current_statement__ = 51;
        assign(x,
          cons_list(index_uni(Imild),
            cons_list(index_uni(1), nil_index_list())),
          (((1 - frac_init_E) * initial_infected) * (1 - frac_hosp_0)),
          "assigning variable x");
        current_statement__ = 52;
        assign(x,
          cons_list(index_uni(Ipreh),
            cons_list(index_uni(1), nil_index_list())),
          (((1 - frac_init_E) * initial_infected) * frac_hosp_0),
          "assigning variable x");
        current_statement__ = 53;
        assign(x,
          cons_list(index_uni(P), cons_list(index_uni(1), nil_index_list())),
          (npop * VE_infection), "assigning variable x");
        current_statement__ = 54;
        assign(x,
          cons_list(index_uni(S), cons_list(index_uni(1), nil_index_list())),
          ((npop - initial_infected) -
            rvalue(x,
              cons_list(index_uni(P),
                cons_list(index_uni(1), nil_index_list())), "x")),
          "assigning variable x");
        current_statement__ = 55;
        assign(soon_positive, cons_list(index_uni(1), nil_index_list()), 0.0,
          "assigning variable soon_positive");
        current_statement__ = 56;
        assign(new_cases, cons_list(index_uni(1), nil_index_list()), 0.0,
          "assigning variable new_cases");
        current_statement__ = 59;
        if (logical_eq(tobs[(obs_cases - 1)][(1 - 1)], 1)) {
          current_statement__ = 57;
          std::stringstream errmsg_stream__;
          errmsg_stream__ << "Minimum tobs[obs_cases, :] is 2";
          throw std::domain_error(errmsg_stream__.str());
        } 
        current_statement__ = 60;
        beta_0 = (((omicron_trans_multiplier / duration_rec_mild) * 1.0) /
                   (1 - VE_infection_delta));
        current_statement__ = 66;
        for (int it = 1; it <= nt; ++it) {
          current_statement__ = 61;
          assign(beta, cons_list(index_uni(it), nil_index_list()), beta_0,
            "assigning variable beta");
          current_statement__ = 64;
          for (int iinter = 1; iinter <= ninter; ++iinter) {
            current_statement__ = 62;
            assign(beta, cons_list(index_uni(it), nil_index_list()),
              (beta[(it - 1)] *
                pow(beta_multiplier[(iinter - 1)],
                  inv_logit(
                    ((9.19024 / len_inter[(iinter - 1)]) *
                      (it -
                        (t_inter[(iinter - 1)] +
                          (len_inter[(iinter - 1)] / 2))))))),
              "assigning variable beta");}}
        current_statement__ = 97;
        for (int it = 1; it <= (nt - 1); ++it) {
          current_statement__ = 67;
          newE = stan::math::fmin(
                   rvalue(x,
                     cons_list(index_uni(S),
                       cons_list(index_uni(it), nil_index_list())), "x"),
                   (((beta[(it - 1)] *
                       rvalue(x,
                         cons_list(index_uni(S),
                           cons_list(index_uni(it), nil_index_list())), "x"))
                      *
                      rvalue(x,
                        cons_list(index_uni(Imild),
                          cons_list(index_uni(it), nil_index_list())), "x"))
                     / npop));
          current_statement__ = 68;
          newI = (rvalue(x,
                    cons_list(index_uni(E),
                      cons_list(index_uni(it), nil_index_list())), "x") /
                   duration_latent);
          current_statement__ = 69;
          frac_boosters_to_susceptible = (rvalue(x,
                                            cons_list(index_uni(S),
                                              cons_list(index_uni(it),
                                                nil_index_list())), "x") /
                                           (rvalue(x,
                                              cons_list(index_uni(S),
                                                cons_list(index_uni(it),
                                                  nil_index_list())), "x") +
                                             (omicron_recovered_booster_scale
                                               *
                                               rvalue(x,
                                                 cons_list(index_uni(Rlive),
                                                   cons_list(index_uni(it),
                                                     nil_index_list())), "x"))));
          current_statement__ = 70;
          new_protected = stan::math::fmin(
                            (rvalue(x,
                               cons_list(index_uni(S),
                                 cons_list(index_uni(it), nil_index_list())),
                               "x") - newE),
                            ((num_boosters[(it - 1)] *
                               frac_boosters_to_susceptible) *
                              booster_VE_infection));
          current_statement__ = 72;
          if (logical_lt(new_protected, 0)) {
            current_statement__ = 71;
            std::stringstream errmsg_stream__;
            errmsg_stream__ << "new_protected < 0";
            throw std::domain_error(errmsg_stream__.str());
          } 
          current_statement__ = 73;
          increased_severity_protection = ((num_boosters[(it - 1)] *
                                             frac_boosters_to_susceptible) *
                                            (1 - booster_VE_infection));
          current_statement__ = 74;
          frac_increased_severity_protection = (increased_severity_protection
                                                 /
                                                 stan::math::fmax(
                                                   rvalue(x,
                                                     cons_list(index_uni(S),
                                                       cons_list(
                                                         index_uni(it),
                                                         nil_index_list())),
                                                     "x"), 0.001));
          current_statement__ = 75;
          VE_severe_given_infection = ((booster_VE_severe_given_infection *
                                         frac_increased_severity_protection)
                                        +
                                        (VE_severe_given_infection *
                                          (1 -
                                            frac_increased_severity_protection)));
          current_statement__ = 76;
          frac_hosp = ((frac_hosp_lemma * (1 - VE_severe_given_infection)) *
                        severity);
          current_statement__ = 77;
          new_admits = (rvalue(x,
                          cons_list(index_uni(Ipreh),
                            cons_list(index_uni(it), nil_index_list())), "x")
                         / duration_pre_hosp);
          current_statement__ = 78;
          lost_protection_infection = (rvalue(x,
                                         cons_list(index_uni(P),
                                           cons_list(index_uni(it),
                                             nil_index_list())), "x") /
                                        duration_protection_infection);
          current_statement__ = 79;
          assign(x,
            cons_list(index_uni(S),
              cons_list(index_uni((it + 1)), nil_index_list())),
            ((((rvalue(x,
                  cons_list(index_uni(S),
                    cons_list(index_uni(it), nil_index_list())), "x") -
                 new_protected) - newE) + lost_protection_infection) +
              (rvalue(x,
                 cons_list(index_uni(Rlive),
                   cons_list(index_uni(it), nil_index_list())), "x") /
                duration_protection_infection)), "assigning variable x");
          current_statement__ = 80;
          assign(x,
            cons_list(index_uni(E),
              cons_list(index_uni((it + 1)), nil_index_list())),
            ((rvalue(x,
                cons_list(index_uni(E),
                  cons_list(index_uni(it), nil_index_list())), "x") + newE) -
              newI), "assigning variable x");
          current_statement__ = 81;
          assign(x,
            cons_list(index_uni(Imild),
              cons_list(index_uni((it + 1)), nil_index_list())),
            ((rvalue(x,
                cons_list(index_uni(Imild),
                  cons_list(index_uni(it), nil_index_list())), "x") +
               (newI * (1 - frac_hosp))) -
              (rvalue(x,
                 cons_list(index_uni(Imild),
                   cons_list(index_uni(it), nil_index_list())), "x") /
                duration_rec_mild)), "assigning variable x");
          current_statement__ = 82;
          assign(x,
            cons_list(index_uni(Ipreh),
              cons_list(index_uni((it + 1)), nil_index_list())),
            ((rvalue(x,
                cons_list(index_uni(Ipreh),
                  cons_list(index_uni(it), nil_index_list())), "x") +
               (newI * frac_hosp)) - new_admits), "assigning variable x");
          current_statement__ = 83;
          assign(x,
            cons_list(index_uni(Hmod),
              cons_list(index_uni((it + 1)), nil_index_list())),
            ((rvalue(x,
                cons_list(index_uni(Hmod),
                  cons_list(index_uni(it), nil_index_list())), "x") +
               new_admits) -
              (rvalue(x,
                 cons_list(index_uni(Hmod),
                   cons_list(index_uni(it), nil_index_list())), "x") /
                duration_hosp_mod)), "assigning variable x");
          current_statement__ = 84;
          assign(x,
            cons_list(index_uni(Rlive),
              cons_list(index_uni((it + 1)), nil_index_list())),
            (((rvalue(x,
                 cons_list(index_uni(Rlive),
                   cons_list(index_uni(it), nil_index_list())), "x") +
                (rvalue(x,
                   cons_list(index_uni(Hmod),
                     cons_list(index_uni(it), nil_index_list())), "x") /
                  duration_hosp_mod)) +
               (rvalue(x,
                  cons_list(index_uni(Imild),
                    cons_list(index_uni(it), nil_index_list())), "x") /
                 duration_rec_mild)) -
              (rvalue(x,
                 cons_list(index_uni(Rlive),
                   cons_list(index_uni(it), nil_index_list())), "x") /
                duration_protection_infection)), "assigning variable x");
          current_statement__ = 85;
          assign(x,
            cons_list(index_uni(P),
              cons_list(index_uni((it + 1)), nil_index_list())),
            ((rvalue(x,
                cons_list(index_uni(P),
                  cons_list(index_uni(it), nil_index_list())), "x") +
               new_protected) - lost_protection_infection),
            "assigning variable x");
          current_statement__ = 86;
          assign(soon_positive,
            cons_list(index_uni((it + 1)), nil_index_list()),
            ((soon_positive[(it - 1)] + (newE * frac_tested)) -
              (soon_positive[(it - 1)] / test_delay)),
            "assigning variable soon_positive");
          current_statement__ = 87;
          assign(new_cases, cons_list(index_uni((it + 1)), nil_index_list()),
            (soon_positive[((it + 1) - 1)] / test_delay),
            "assigning variable new_cases");
          current_statement__ = 92;
          if (is_nan(new_cases[((it + 1) - 1)])) {
            current_statement__ = 88;
            if (pstream__) {
              stan_print(pstream__, "is nan cases:");
              stan_print(pstream__, "\n");
            }
            current_statement__ = 89;
            if (pstream__) {
              stan_print(pstream__, it);
              stan_print(pstream__, " ");
              stan_print(pstream__, soon_positive[(it - 1)]);
              stan_print(pstream__, " ");
              stan_print(pstream__, soon_positive[((it + 1) - 1)]);
              stan_print(pstream__, " ");
              stan_print(pstream__, newE);
              stan_print(pstream__, " ");
              stan_print(pstream__, frac_tested);
              stan_print(pstream__, " ");
              stan_print(pstream__, test_delay);
              stan_print(pstream__, "\n");
            }
            current_statement__ = 90;
            std::stringstream errmsg_stream__;
            errmsg_stream__ << "new_cases[it+1] is nan";
            throw std::domain_error(errmsg_stream__.str());
          } 
          current_statement__ = 95;
          if (logical_gt(
                stan::math::fabs(
                  (sum(
                     rvalue(x,
                       cons_list(index_omni(),
                         cons_list(index_uni((it + 1)), nil_index_list())),
                       "x")) - npop)), 0.01)) {
            current_statement__ = 93;
            std::stringstream errmsg_stream__;
            errmsg_stream__ << "Model is leaking, net gain: ";
            errmsg_stream__ << (sum(
                                  rvalue(x,
                                    cons_list(index_omni(),
                                      cons_list(index_uni((it + 1)),
                                        nil_index_list())), "x")) - npop);
            throw std::domain_error(errmsg_stream__.str());
          } }
        current_statement__ = 98;
        assign(sim_data,
          cons_list(index_uni(obs_hosp_census), nil_index_list()),
          add(
            multiply(
              rvalue(x, cons_list(index_uni(Hmod), nil_index_list()), "x"),
              (1 + frac_incidental_omicron)),
            multiply(hosp_delta, hosp_frac_delta)),
          "assigning variable sim_data");
        current_statement__ = 99;
        assign(sim_data, cons_list(index_uni(obs_cases), nil_index_list()),
          add(new_cases, multiply(cases_delta, case_frac_delta)),
          "assigning variable sim_data");
      }
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= ncompartments; ++sym1__) {
        current_statement__ = 15;
        for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
          current_statement__ = 15;
          current_statement__ = 15;
          check_greater_or_equal(function__, "x[sym1__, sym2__]",
                                 rvalue(x,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "x"), 0.0);}}
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= nobs_types; ++sym1__) {
        current_statement__ = 16;
        for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
          current_statement__ = 16;
          current_statement__ = 16;
          check_greater_or_equal(function__, "sim_data[sym1__, sym2__]",
                                 rvalue(sim_data,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "sim_data"), 0.0);
        }}
      current_statement__ = 17;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 17;
        current_statement__ = 17;
        check_greater_or_equal(function__, "new_cases[sym1__]",
                               new_cases[(sym1__ - 1)], 0.0);}
      current_statement__ = 18;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 18;
        current_statement__ = 18;
        check_greater_or_equal(function__, "soon_positive[sym1__]",
                               soon_positive[(sym1__ - 1)], 0.0);}
      current_statement__ = 19;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 19;
        current_statement__ = 19;
        check_greater_or_equal(function__, "beta[sym1__]",
                               beta[(sym1__ - 1)], 0.0);}
      current_statement__ = 20;
      current_statement__ = 20;
      check_greater_or_equal(function__, "frac_hosp_0", frac_hosp_0, 0.0);
      {
        current_statement__ = 117;
        lp_accum__.add(
          normal_lpdf<propto__>(duration_latent, mu_duration_latent,
            sigma_duration_latent));
        current_statement__ = 118;
        lp_accum__.add(
          normal_lpdf<propto__>(duration_rec_mild, mu_duration_rec_mild,
            sigma_duration_rec_mild));
        current_statement__ = 119;
        lp_accum__.add(
          normal_lpdf<propto__>(duration_pre_hosp, mu_duration_pre_hosp,
            sigma_duration_pre_hosp));
        current_statement__ = 120;
        lp_accum__.add(
          normal_lpdf<propto__>(duration_hosp_mod, mu_duration_hosp_mod,
            sigma_duration_hosp_mod));
        current_statement__ = 121;
        lp_accum__.add(
          normal_lpdf<propto__>(duration_protection_infection,
            mu_duration_protection_infection,
            sigma_duration_protection_infection));
        current_statement__ = 124;
        for (int iinter = 1; iinter <= ninter; ++iinter) {
          current_statement__ = 122;
          lp_accum__.add(
            normal_lpdf<propto__>(beta_multiplier[(iinter - 1)],
              mu_beta_inter[(iinter - 1)], sigma_beta_inter[(iinter - 1)]));}
        current_statement__ = 125;
        lp_accum__.add(
          normal_lpdf<propto__>(frac_tested, mu_frac_tested,
            sigma_frac_tested));
        current_statement__ = 126;
        lp_accum__.add(
          normal_lpdf<propto__>(severity, mu_severity, sigma_severity));
        current_statement__ = 127;
        lp_accum__.add(
          normal_lpdf<propto__>(omicron_trans_multiplier,
            mu_omicron_trans_multiplier, sigma_omicron_trans_multiplier));
        current_statement__ = 128;
        lp_accum__.add(
          normal_lpdf<propto__>(test_delay, mu_test_delay, sigma_test_delay));
        current_statement__ = 129;
        lp_accum__.add(
          normal_lpdf<propto__>(hosp_delta, mu_hosp_delta, sigma_hosp_delta));
        current_statement__ = 130;
        lp_accum__.add(
          normal_lpdf<propto__>(cases_delta, mu_cases_delta,
            sigma_cases_delta));
        current_statement__ = 131;
        lp_accum__.add(
          exponential_lpdf<propto__>(initial_infected,
            lambda_initial_infected));
        current_statement__ = 132;
        lp_accum__.add(
          exponential_lpdf<propto__>(sigma_obs, sigma_obs_est_inv));
        current_statement__ = 137;
        for (int itype = 1; itype <= nobs_types; ++itype) {
          current_statement__ = 135;
          if (logical_gt(nobs[(itype - 1)], 0)) {
            current_statement__ = 133;
            lp_accum__.add(
              normal_lpdf<propto__>(
                rvalue(obs_data,
                  cons_list(index_uni(itype),
                    cons_list(index_min_max(1, nobs[(itype - 1)]),
                      nil_index_list())), "obs_data"),
                rvalue(sim_data,
                  cons_list(index_uni(itype),
                    cons_list(
                      index_multi(rvalue(tobs,
                                    cons_list(index_uni(itype),
                                      cons_list(
                                        index_min_max(1, nobs[(itype - 1)]),
                                        nil_index_list())), "tobs")),
                      nil_index_list())), "sim_data"),
                sigma_obs[(itype - 1)]));
          } }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "model_LEMMA_namespace::write_array";
(void) function__;  // suppress unused var warning
    (void) function__;  // suppress unused var warning
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      double duration_latent;
      duration_latent = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      duration_latent = in__.scalar();
      current_statement__ = 1;
      duration_latent = stan::math::lb_constrain(duration_latent, 1.0);
      double duration_rec_mild;
      duration_rec_mild = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      duration_rec_mild = in__.scalar();
      current_statement__ = 2;
      duration_rec_mild = stan::math::lb_constrain(duration_rec_mild, 1.0);
      double duration_pre_hosp;
      duration_pre_hosp = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      duration_pre_hosp = in__.scalar();
      current_statement__ = 3;
      duration_pre_hosp = stan::math::lb_constrain(duration_pre_hosp, 1.0);
      double duration_hosp_mod;
      duration_hosp_mod = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      duration_hosp_mod = in__.scalar();
      current_statement__ = 4;
      duration_hosp_mod = stan::math::lb_constrain(duration_hosp_mod, 1.0);
      double duration_protection_infection;
      duration_protection_infection = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      duration_protection_infection = in__.scalar();
      current_statement__ = 5;
      duration_protection_infection = stan::math::lb_constrain(
                                        duration_protection_infection, 1.0);
      double frac_tested;
      frac_tested = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      frac_tested = in__.scalar();
      current_statement__ = 6;
      frac_tested = stan::math::lub_constrain(frac_tested, 0.0, 1.0);
      double initial_infected;
      initial_infected = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 7;
      initial_infected = in__.scalar();
      current_statement__ = 7;
      initial_infected = stan::math::lb_constrain(initial_infected, 0.0);
      std::vector<double> sigma_obs;
      sigma_obs = std::vector<double>(nobs_types, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= nobs_types; ++sym1__) {
        current_statement__ = 8;
        assign(sigma_obs, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable sigma_obs");}
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= nobs_types; ++sym1__) {
        current_statement__ = 8;
        assign(sigma_obs, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(sigma_obs[(sym1__ - 1)], 0.0),
          "assigning variable sigma_obs");}
      double severity;
      severity = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 9;
      severity = in__.scalar();
      current_statement__ = 9;
      severity = stan::math::lb_constrain(severity, 0.0);
      double omicron_trans_multiplier;
      omicron_trans_multiplier = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 10;
      omicron_trans_multiplier = in__.scalar();
      current_statement__ = 10;
      omicron_trans_multiplier = stan::math::lb_constrain(
                                   omicron_trans_multiplier, 0.0);
      double test_delay;
      test_delay = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 11;
      test_delay = in__.scalar();
      current_statement__ = 11;
      test_delay = stan::math::lb_constrain(test_delay, 1.0);
      double hosp_delta;
      hosp_delta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 12;
      hosp_delta = in__.scalar();
      current_statement__ = 12;
      hosp_delta = stan::math::lb_constrain(hosp_delta, 0.0);
      double cases_delta;
      cases_delta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 13;
      cases_delta = in__.scalar();
      current_statement__ = 13;
      cases_delta = stan::math::lb_constrain(cases_delta, 0.0);
      std::vector<double> beta_multiplier;
      beta_multiplier = std::vector<double>(ninter, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= ninter; ++sym1__) {
        current_statement__ = 14;
        assign(beta_multiplier,
          cons_list(index_uni(sym1__), nil_index_list()), in__.scalar(),
          "assigning variable beta_multiplier");}
      current_statement__ = 14;
      check_matching_dims("constraint", "beta_multiplier", beta_multiplier,
                          "lower", lbd_beta_inter);
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= ninter; ++sym1__) {
        current_statement__ = 14;
        assign(beta_multiplier,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(beta_multiplier[(sym1__ - 1)],
            lbd_beta_inter[(sym1__ - 1)]),
          "assigning variable beta_multiplier");}
      Eigen::Matrix<double, -1, -1> x;
      x = Eigen::Matrix<double, -1, -1>(ncompartments, nt);
      stan::math::fill(x, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> sim_data;
      sim_data = Eigen::Matrix<double, -1, -1>(nobs_types, nt);
      stan::math::fill(sim_data, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, 1, -1> new_cases;
      new_cases = Eigen::Matrix<double, 1, -1>(nt);
      stan::math::fill(new_cases, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, 1, -1> soon_positive;
      soon_positive = Eigen::Matrix<double, 1, -1>(nt);
      stan::math::fill(soon_positive, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> beta;
      beta = std::vector<double>(nt, std::numeric_limits<double>::quiet_NaN());
      
      double frac_hosp_0;
      frac_hosp_0 = std::numeric_limits<double>::quiet_NaN();
      
      vars__.emplace_back(duration_latent);
      vars__.emplace_back(duration_rec_mild);
      vars__.emplace_back(duration_pre_hosp);
      vars__.emplace_back(duration_hosp_mod);
      vars__.emplace_back(duration_protection_infection);
      vars__.emplace_back(frac_tested);
      vars__.emplace_back(initial_infected);
      for (int sym1__ = 1; sym1__ <= nobs_types; ++sym1__) {
        vars__.emplace_back(sigma_obs[(sym1__ - 1)]);}
      vars__.emplace_back(severity);
      vars__.emplace_back(omicron_trans_multiplier);
      vars__.emplace_back(test_delay);
      vars__.emplace_back(hosp_delta);
      vars__.emplace_back(cases_delta);
      for (int sym1__ = 1; sym1__ <= ninter; ++sym1__) {
        vars__.emplace_back(beta_multiplier[(sym1__ - 1)]);}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 25;
      for (int it = 1; it <= nt; ++it) {
        current_statement__ = 23;
        for (int itype = 1; itype <= nobs_types; ++itype) {
          current_statement__ = 21;
          assign(sim_data,
            cons_list(index_uni(itype),
              cons_list(index_uni(it), nil_index_list())), 0.0,
            "assigning variable sim_data");}}
      {
        double newE;
        newE = std::numeric_limits<double>::quiet_NaN();
        
        double newI;
        newI = std::numeric_limits<double>::quiet_NaN();
        
        double frac_init_E;
        frac_init_E = std::numeric_limits<double>::quiet_NaN();
        
        double beta_0;
        beta_0 = std::numeric_limits<double>::quiet_NaN();
        
        double frac_hosp;
        frac_hosp = std::numeric_limits<double>::quiet_NaN();
        
        double frac_boosters_to_susceptible;
        frac_boosters_to_susceptible = std::numeric_limits<double>::quiet_NaN();
        
        double new_protected;
        new_protected = std::numeric_limits<double>::quiet_NaN();
        
        double increased_severity_protection;
        increased_severity_protection = std::numeric_limits<double>::quiet_NaN();
        
        double frac_increased_severity_protection;
        frac_increased_severity_protection = std::numeric_limits<double>::quiet_NaN();
        
        double new_admits;
        new_admits = std::numeric_limits<double>::quiet_NaN();
        
        double VE_severe_given_infection;
        VE_severe_given_infection = std::numeric_limits<double>::quiet_NaN();
        
        double lost_protection_infection;
        lost_protection_infection = std::numeric_limits<double>::quiet_NaN();
        
        current_statement__ = 38;
        validate_non_negative_index("hosp_frac_delta", "nt", nt);
        Eigen::Matrix<double, 1, -1> hosp_frac_delta;
        hosp_frac_delta = Eigen::Matrix<double, 1, -1>(nt);
        stan::math::fill(hosp_frac_delta, std::numeric_limits<double>::quiet_NaN());
        
        current_statement__ = 40;
        validate_non_negative_index("case_frac_delta", "nt", nt);
        Eigen::Matrix<double, 1, -1> case_frac_delta;
        case_frac_delta = Eigen::Matrix<double, 1, -1>(nt);
        stan::math::fill(case_frac_delta, std::numeric_limits<double>::quiet_NaN());
        
        current_statement__ = 45;
        for (int it = 1; it <= nt; ++it) {
          current_statement__ = 42;
          assign(hosp_frac_delta, cons_list(index_uni(it), nil_index_list()),
            (1 /
              (1 +
                (hosp_frac_delta_0 * stan::math::exp((it * omicron_growth))))),
            "assigning variable hosp_frac_delta");
          current_statement__ = 43;
          assign(case_frac_delta, cons_list(index_uni(it), nil_index_list()),
            (1 /
              (1 +
                (case_frac_delta_0 * stan::math::exp((it * omicron_growth))))),
            "assigning variable case_frac_delta");}
        current_statement__ = 46;
        VE_severe_given_infection = VE_severe_given_infection_0;
        current_statement__ = 47;
        frac_hosp_0 = ((frac_hosp_lemma * (1 - VE_severe_given_infection)) *
                        severity);
        current_statement__ = 48;
        assign(x,
          cons_list(index_omni(), cons_list(index_uni(1), nil_index_list())),
          rep_vector(0.0, ncompartments), "assigning variable x");
        current_statement__ = 49;
        frac_init_E = (duration_latent /
                        (duration_latent + duration_rec_mild));
        current_statement__ = 50;
        assign(x,
          cons_list(index_uni(E), cons_list(index_uni(1), nil_index_list())),
          (frac_init_E * initial_infected), "assigning variable x");
        current_statement__ = 51;
        assign(x,
          cons_list(index_uni(Imild),
            cons_list(index_uni(1), nil_index_list())),
          (((1 - frac_init_E) * initial_infected) * (1 - frac_hosp_0)),
          "assigning variable x");
        current_statement__ = 52;
        assign(x,
          cons_list(index_uni(Ipreh),
            cons_list(index_uni(1), nil_index_list())),
          (((1 - frac_init_E) * initial_infected) * frac_hosp_0),
          "assigning variable x");
        current_statement__ = 53;
        assign(x,
          cons_list(index_uni(P), cons_list(index_uni(1), nil_index_list())),
          (npop * VE_infection), "assigning variable x");
        current_statement__ = 54;
        assign(x,
          cons_list(index_uni(S), cons_list(index_uni(1), nil_index_list())),
          ((npop - initial_infected) -
            rvalue(x,
              cons_list(index_uni(P),
                cons_list(index_uni(1), nil_index_list())), "x")),
          "assigning variable x");
        current_statement__ = 55;
        assign(soon_positive, cons_list(index_uni(1), nil_index_list()), 0.0,
          "assigning variable soon_positive");
        current_statement__ = 56;
        assign(new_cases, cons_list(index_uni(1), nil_index_list()), 0.0,
          "assigning variable new_cases");
        current_statement__ = 59;
        if (logical_eq(tobs[(obs_cases - 1)][(1 - 1)], 1)) {
          current_statement__ = 57;
          std::stringstream errmsg_stream__;
          errmsg_stream__ << "Minimum tobs[obs_cases, :] is 2";
          throw std::domain_error(errmsg_stream__.str());
        } 
        current_statement__ = 60;
        beta_0 = (((omicron_trans_multiplier / duration_rec_mild) * 1.0) /
                   (1 - VE_infection_delta));
        current_statement__ = 66;
        for (int it = 1; it <= nt; ++it) {
          current_statement__ = 61;
          assign(beta, cons_list(index_uni(it), nil_index_list()), beta_0,
            "assigning variable beta");
          current_statement__ = 64;
          for (int iinter = 1; iinter <= ninter; ++iinter) {
            current_statement__ = 62;
            assign(beta, cons_list(index_uni(it), nil_index_list()),
              (beta[(it - 1)] *
                pow(beta_multiplier[(iinter - 1)],
                  inv_logit(
                    ((9.19024 / len_inter[(iinter - 1)]) *
                      (it -
                        (t_inter[(iinter - 1)] +
                          (len_inter[(iinter - 1)] / 2))))))),
              "assigning variable beta");}}
        current_statement__ = 97;
        for (int it = 1; it <= (nt - 1); ++it) {
          current_statement__ = 67;
          newE = stan::math::fmin(
                   rvalue(x,
                     cons_list(index_uni(S),
                       cons_list(index_uni(it), nil_index_list())), "x"),
                   (((beta[(it - 1)] *
                       rvalue(x,
                         cons_list(index_uni(S),
                           cons_list(index_uni(it), nil_index_list())), "x"))
                      *
                      rvalue(x,
                        cons_list(index_uni(Imild),
                          cons_list(index_uni(it), nil_index_list())), "x"))
                     / npop));
          current_statement__ = 68;
          newI = (rvalue(x,
                    cons_list(index_uni(E),
                      cons_list(index_uni(it), nil_index_list())), "x") /
                   duration_latent);
          current_statement__ = 69;
          frac_boosters_to_susceptible = (rvalue(x,
                                            cons_list(index_uni(S),
                                              cons_list(index_uni(it),
                                                nil_index_list())), "x") /
                                           (rvalue(x,
                                              cons_list(index_uni(S),
                                                cons_list(index_uni(it),
                                                  nil_index_list())), "x") +
                                             (omicron_recovered_booster_scale
                                               *
                                               rvalue(x,
                                                 cons_list(index_uni(Rlive),
                                                   cons_list(index_uni(it),
                                                     nil_index_list())), "x"))));
          current_statement__ = 70;
          new_protected = stan::math::fmin(
                            (rvalue(x,
                               cons_list(index_uni(S),
                                 cons_list(index_uni(it), nil_index_list())),
                               "x") - newE),
                            ((num_boosters[(it - 1)] *
                               frac_boosters_to_susceptible) *
                              booster_VE_infection));
          current_statement__ = 72;
          if (logical_lt(new_protected, 0)) {
            current_statement__ = 71;
            std::stringstream errmsg_stream__;
            errmsg_stream__ << "new_protected < 0";
            throw std::domain_error(errmsg_stream__.str());
          } 
          current_statement__ = 73;
          increased_severity_protection = ((num_boosters[(it - 1)] *
                                             frac_boosters_to_susceptible) *
                                            (1 - booster_VE_infection));
          current_statement__ = 74;
          frac_increased_severity_protection = (increased_severity_protection
                                                 /
                                                 stan::math::fmax(
                                                   rvalue(x,
                                                     cons_list(index_uni(S),
                                                       cons_list(
                                                         index_uni(it),
                                                         nil_index_list())),
                                                     "x"), 0.001));
          current_statement__ = 75;
          VE_severe_given_infection = ((booster_VE_severe_given_infection *
                                         frac_increased_severity_protection)
                                        +
                                        (VE_severe_given_infection *
                                          (1 -
                                            frac_increased_severity_protection)));
          current_statement__ = 76;
          frac_hosp = ((frac_hosp_lemma * (1 - VE_severe_given_infection)) *
                        severity);
          current_statement__ = 77;
          new_admits = (rvalue(x,
                          cons_list(index_uni(Ipreh),
                            cons_list(index_uni(it), nil_index_list())), "x")
                         / duration_pre_hosp);
          current_statement__ = 78;
          lost_protection_infection = (rvalue(x,
                                         cons_list(index_uni(P),
                                           cons_list(index_uni(it),
                                             nil_index_list())), "x") /
                                        duration_protection_infection);
          current_statement__ = 79;
          assign(x,
            cons_list(index_uni(S),
              cons_list(index_uni((it + 1)), nil_index_list())),
            ((((rvalue(x,
                  cons_list(index_uni(S),
                    cons_list(index_uni(it), nil_index_list())), "x") -
                 new_protected) - newE) + lost_protection_infection) +
              (rvalue(x,
                 cons_list(index_uni(Rlive),
                   cons_list(index_uni(it), nil_index_list())), "x") /
                duration_protection_infection)), "assigning variable x");
          current_statement__ = 80;
          assign(x,
            cons_list(index_uni(E),
              cons_list(index_uni((it + 1)), nil_index_list())),
            ((rvalue(x,
                cons_list(index_uni(E),
                  cons_list(index_uni(it), nil_index_list())), "x") + newE) -
              newI), "assigning variable x");
          current_statement__ = 81;
          assign(x,
            cons_list(index_uni(Imild),
              cons_list(index_uni((it + 1)), nil_index_list())),
            ((rvalue(x,
                cons_list(index_uni(Imild),
                  cons_list(index_uni(it), nil_index_list())), "x") +
               (newI * (1 - frac_hosp))) -
              (rvalue(x,
                 cons_list(index_uni(Imild),
                   cons_list(index_uni(it), nil_index_list())), "x") /
                duration_rec_mild)), "assigning variable x");
          current_statement__ = 82;
          assign(x,
            cons_list(index_uni(Ipreh),
              cons_list(index_uni((it + 1)), nil_index_list())),
            ((rvalue(x,
                cons_list(index_uni(Ipreh),
                  cons_list(index_uni(it), nil_index_list())), "x") +
               (newI * frac_hosp)) - new_admits), "assigning variable x");
          current_statement__ = 83;
          assign(x,
            cons_list(index_uni(Hmod),
              cons_list(index_uni((it + 1)), nil_index_list())),
            ((rvalue(x,
                cons_list(index_uni(Hmod),
                  cons_list(index_uni(it), nil_index_list())), "x") +
               new_admits) -
              (rvalue(x,
                 cons_list(index_uni(Hmod),
                   cons_list(index_uni(it), nil_index_list())), "x") /
                duration_hosp_mod)), "assigning variable x");
          current_statement__ = 84;
          assign(x,
            cons_list(index_uni(Rlive),
              cons_list(index_uni((it + 1)), nil_index_list())),
            (((rvalue(x,
                 cons_list(index_uni(Rlive),
                   cons_list(index_uni(it), nil_index_list())), "x") +
                (rvalue(x,
                   cons_list(index_uni(Hmod),
                     cons_list(index_uni(it), nil_index_list())), "x") /
                  duration_hosp_mod)) +
               (rvalue(x,
                  cons_list(index_uni(Imild),
                    cons_list(index_uni(it), nil_index_list())), "x") /
                 duration_rec_mild)) -
              (rvalue(x,
                 cons_list(index_uni(Rlive),
                   cons_list(index_uni(it), nil_index_list())), "x") /
                duration_protection_infection)), "assigning variable x");
          current_statement__ = 85;
          assign(x,
            cons_list(index_uni(P),
              cons_list(index_uni((it + 1)), nil_index_list())),
            ((rvalue(x,
                cons_list(index_uni(P),
                  cons_list(index_uni(it), nil_index_list())), "x") +
               new_protected) - lost_protection_infection),
            "assigning variable x");
          current_statement__ = 86;
          assign(soon_positive,
            cons_list(index_uni((it + 1)), nil_index_list()),
            ((soon_positive[(it - 1)] + (newE * frac_tested)) -
              (soon_positive[(it - 1)] / test_delay)),
            "assigning variable soon_positive");
          current_statement__ = 87;
          assign(new_cases, cons_list(index_uni((it + 1)), nil_index_list()),
            (soon_positive[((it + 1) - 1)] / test_delay),
            "assigning variable new_cases");
          current_statement__ = 92;
          if (is_nan(new_cases[((it + 1) - 1)])) {
            current_statement__ = 88;
            if (pstream__) {
              stan_print(pstream__, "is nan cases:");
              stan_print(pstream__, "\n");
            }
            current_statement__ = 89;
            if (pstream__) {
              stan_print(pstream__, it);
              stan_print(pstream__, " ");
              stan_print(pstream__, soon_positive[(it - 1)]);
              stan_print(pstream__, " ");
              stan_print(pstream__, soon_positive[((it + 1) - 1)]);
              stan_print(pstream__, " ");
              stan_print(pstream__, newE);
              stan_print(pstream__, " ");
              stan_print(pstream__, frac_tested);
              stan_print(pstream__, " ");
              stan_print(pstream__, test_delay);
              stan_print(pstream__, "\n");
            }
            current_statement__ = 90;
            std::stringstream errmsg_stream__;
            errmsg_stream__ << "new_cases[it+1] is nan";
            throw std::domain_error(errmsg_stream__.str());
          } 
          current_statement__ = 95;
          if (logical_gt(
                stan::math::fabs(
                  (sum(
                     rvalue(x,
                       cons_list(index_omni(),
                         cons_list(index_uni((it + 1)), nil_index_list())),
                       "x")) - npop)), 0.01)) {
            current_statement__ = 93;
            std::stringstream errmsg_stream__;
            errmsg_stream__ << "Model is leaking, net gain: ";
            errmsg_stream__ << (sum(
                                  rvalue(x,
                                    cons_list(index_omni(),
                                      cons_list(index_uni((it + 1)),
                                        nil_index_list())), "x")) - npop);
            throw std::domain_error(errmsg_stream__.str());
          } }
        current_statement__ = 98;
        assign(sim_data,
          cons_list(index_uni(obs_hosp_census), nil_index_list()),
          add(
            multiply(
              rvalue(x, cons_list(index_uni(Hmod), nil_index_list()), "x"),
              (1 + frac_incidental_omicron)),
            multiply(hosp_delta, hosp_frac_delta)),
          "assigning variable sim_data");
        current_statement__ = 99;
        assign(sim_data, cons_list(index_uni(obs_cases), nil_index_list()),
          add(new_cases, multiply(cases_delta, case_frac_delta)),
          "assigning variable sim_data");
      }
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= ncompartments; ++sym1__) {
        current_statement__ = 15;
        for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
          current_statement__ = 15;
          current_statement__ = 15;
          check_greater_or_equal(function__, "x[sym1__, sym2__]",
                                 rvalue(x,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "x"), 0.0);}}
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= nobs_types; ++sym1__) {
        current_statement__ = 16;
        for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
          current_statement__ = 16;
          current_statement__ = 16;
          check_greater_or_equal(function__, "sim_data[sym1__, sym2__]",
                                 rvalue(sim_data,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "sim_data"), 0.0);
        }}
      current_statement__ = 17;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 17;
        current_statement__ = 17;
        check_greater_or_equal(function__, "new_cases[sym1__]",
                               new_cases[(sym1__ - 1)], 0.0);}
      current_statement__ = 18;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 18;
        current_statement__ = 18;
        check_greater_or_equal(function__, "soon_positive[sym1__]",
                               soon_positive[(sym1__ - 1)], 0.0);}
      current_statement__ = 19;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 19;
        current_statement__ = 19;
        check_greater_or_equal(function__, "beta[sym1__]",
                               beta[(sym1__ - 1)], 0.0);}
      current_statement__ = 20;
      current_statement__ = 20;
      check_greater_or_equal(function__, "frac_hosp_0", frac_hosp_0, 0.0);
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= ncompartments; ++sym2__) {
            vars__.emplace_back(
              rvalue(x,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "x"));}}
        for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= nobs_types; ++sym2__) {
            vars__.emplace_back(
              rvalue(sim_data,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "sim_data"));}}
        for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
          vars__.emplace_back(new_cases[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
          vars__.emplace_back(soon_positive[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
          vars__.emplace_back(beta[(sym1__ - 1)]);}
        vars__.emplace_back(frac_hosp_0);
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      Eigen::Matrix<double, -1, -1> sim_data_with_error;
      sim_data_with_error = Eigen::Matrix<double, -1, -1>(nobs_types, nt);
      stan::math::fill(sim_data_with_error, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> Rt;
      Rt = std::vector<double>(nt, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 111;
      for (int itype = 1; itype <= nobs_types; ++itype) {
        current_statement__ = 109;
        if (logical_gt(nobs[(itype - 1)], 0)) {
          current_statement__ = 107;
          for (int it = 1; it <= nt; ++it) {
            current_statement__ = 105;
            assign(sim_data_with_error,
              cons_list(index_uni(itype),
                cons_list(index_uni(it), nil_index_list())),
              stan::math::fmax(0.0,
                normal_rng(
                  rvalue(sim_data,
                    cons_list(index_uni(itype),
                      cons_list(index_uni(it), nil_index_list())),
                    "sim_data"), sigma_obs[(itype - 1)], base_rng__)),
              "assigning variable sim_data_with_error");}
        } else {
          current_statement__ = 103;
          assign(sim_data_with_error,
            cons_list(index_uni(itype), nil_index_list()),
            rvalue(sim_data, cons_list(index_uni(itype), nil_index_list()),
              "sim_data"), "assigning variable sim_data_with_error");
        }}
      {
        double frac_prehosp;
        frac_prehosp = std::numeric_limits<double>::quiet_NaN();
        
        current_statement__ = 115;
        for (int it = 1; it <= nt; ++it) {
          current_statement__ = 113;
          assign(Rt, cons_list(index_uni(it), nil_index_list()),
            (((beta[(it - 1)] * duration_rec_mild) *
               rvalue(x,
                 cons_list(index_uni(S),
                   cons_list(index_uni(it), nil_index_list())), "x")) / npop),
            "assigning variable Rt");}
      }
      current_statement__ = 101;
      for (int sym1__ = 1; sym1__ <= nobs_types; ++sym1__) {
        current_statement__ = 101;
        for (int sym2__ = 1; sym2__ <= nt; ++sym2__) {
          current_statement__ = 101;
          current_statement__ = 101;
          check_greater_or_equal(function__,
                                 "sim_data_with_error[sym1__, sym2__]",
                                 rvalue(sim_data_with_error,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())),
                                   "sim_data_with_error"), 0.0);}}
      current_statement__ = 102;
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        current_statement__ = 102;
        current_statement__ = 102;
        check_greater_or_equal(function__, "Rt[sym1__]", Rt[(sym1__ - 1)],
                               0.0);}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= nobs_types; ++sym2__) {
          vars__.emplace_back(
            rvalue(sim_data_with_error,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              "sim_data_with_error"));}}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        vars__.emplace_back(Rt[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double duration_latent;
      duration_latent = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      duration_latent = context__.vals_r("duration_latent")[(1 - 1)];
      double duration_latent_free__;
      duration_latent_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      duration_latent_free__ = stan::math::lb_free(duration_latent, 1.0);
      double duration_rec_mild;
      duration_rec_mild = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      duration_rec_mild = context__.vals_r("duration_rec_mild")[(1 - 1)];
      double duration_rec_mild_free__;
      duration_rec_mild_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      duration_rec_mild_free__ = stan::math::lb_free(duration_rec_mild, 1.0);
      double duration_pre_hosp;
      duration_pre_hosp = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      duration_pre_hosp = context__.vals_r("duration_pre_hosp")[(1 - 1)];
      double duration_pre_hosp_free__;
      duration_pre_hosp_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      duration_pre_hosp_free__ = stan::math::lb_free(duration_pre_hosp, 1.0);
      double duration_hosp_mod;
      duration_hosp_mod = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      duration_hosp_mod = context__.vals_r("duration_hosp_mod")[(1 - 1)];
      double duration_hosp_mod_free__;
      duration_hosp_mod_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      duration_hosp_mod_free__ = stan::math::lb_free(duration_hosp_mod, 1.0);
      double duration_protection_infection;
      duration_protection_infection = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      duration_protection_infection = context__.vals_r("duration_protection_infection")[
          (1 - 1)];
      double duration_protection_infection_free__;
      duration_protection_infection_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 5;
      duration_protection_infection_free__ = stan::math::lb_free(
                                               duration_protection_infection,
                                               1.0);
      double frac_tested;
      frac_tested = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      frac_tested = context__.vals_r("frac_tested")[(1 - 1)];
      double frac_tested_free__;
      frac_tested_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      frac_tested_free__ = stan::math::lub_free(frac_tested, 0.0, 1.0);
      double initial_infected;
      initial_infected = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 7;
      initial_infected = context__.vals_r("initial_infected")[(1 - 1)];
      double initial_infected_free__;
      initial_infected_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 7;
      initial_infected_free__ = stan::math::lb_free(initial_infected, 0.0);
      std::vector<double> sigma_obs;
      sigma_obs = std::vector<double>(nobs_types, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 8;
      assign(sigma_obs, nil_index_list(), context__.vals_r("sigma_obs"),
        "assigning variable sigma_obs");
      std::vector<double> sigma_obs_free__;
      sigma_obs_free__ = std::vector<double>(nobs_types, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= nobs_types; ++sym1__) {
        current_statement__ = 8;
        assign(sigma_obs_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(sigma_obs[(sym1__ - 1)], 0.0),
          "assigning variable sigma_obs_free__");}
      double severity;
      severity = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 9;
      severity = context__.vals_r("severity")[(1 - 1)];
      double severity_free__;
      severity_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 9;
      severity_free__ = stan::math::lb_free(severity, 0.0);
      double omicron_trans_multiplier;
      omicron_trans_multiplier = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 10;
      omicron_trans_multiplier = context__.vals_r("omicron_trans_multiplier")[
          (1 - 1)];
      double omicron_trans_multiplier_free__;
      omicron_trans_multiplier_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 10;
      omicron_trans_multiplier_free__ = stan::math::lb_free(
                                          omicron_trans_multiplier, 0.0);
      double test_delay;
      test_delay = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 11;
      test_delay = context__.vals_r("test_delay")[(1 - 1)];
      double test_delay_free__;
      test_delay_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 11;
      test_delay_free__ = stan::math::lb_free(test_delay, 1.0);
      double hosp_delta;
      hosp_delta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 12;
      hosp_delta = context__.vals_r("hosp_delta")[(1 - 1)];
      double hosp_delta_free__;
      hosp_delta_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 12;
      hosp_delta_free__ = stan::math::lb_free(hosp_delta, 0.0);
      double cases_delta;
      cases_delta = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 13;
      cases_delta = context__.vals_r("cases_delta")[(1 - 1)];
      double cases_delta_free__;
      cases_delta_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 13;
      cases_delta_free__ = stan::math::lb_free(cases_delta, 0.0);
      std::vector<double> beta_multiplier;
      beta_multiplier = std::vector<double>(ninter, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 14;
      assign(beta_multiplier, nil_index_list(),
        context__.vals_r("beta_multiplier"),
        "assigning variable beta_multiplier");
      current_statement__ = 14;
      check_matching_dims("constraint", "beta_multiplier", beta_multiplier,
                          "lower", lbd_beta_inter);
      std::vector<double> beta_multiplier_free__;
      beta_multiplier_free__ = std::vector<double>(ninter, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 14;
      for (int sym1__ = 1; sym1__ <= ninter; ++sym1__) {
        current_statement__ = 14;
        assign(beta_multiplier_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(beta_multiplier[(sym1__ - 1)],
            lbd_beta_inter[(sym1__ - 1)]),
          "assigning variable beta_multiplier_free__");}
      vars__.emplace_back(duration_latent_free__);
      vars__.emplace_back(duration_rec_mild_free__);
      vars__.emplace_back(duration_pre_hosp_free__);
      vars__.emplace_back(duration_hosp_mod_free__);
      vars__.emplace_back(duration_protection_infection_free__);
      vars__.emplace_back(frac_tested_free__);
      vars__.emplace_back(initial_infected_free__);
      for (int sym1__ = 1; sym1__ <= nobs_types; ++sym1__) {
        vars__.emplace_back(sigma_obs_free__[(sym1__ - 1)]);}
      vars__.emplace_back(severity_free__);
      vars__.emplace_back(omicron_trans_multiplier_free__);
      vars__.emplace_back(test_delay_free__);
      vars__.emplace_back(hosp_delta_free__);
      vars__.emplace_back(cases_delta_free__);
      for (int sym1__ = 1; sym1__ <= ninter; ++sym1__) {
        vars__.emplace_back(beta_multiplier_free__[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("duration_latent");
    names__.emplace_back("duration_rec_mild");
    names__.emplace_back("duration_pre_hosp");
    names__.emplace_back("duration_hosp_mod");
    names__.emplace_back("duration_protection_infection");
    names__.emplace_back("frac_tested");
    names__.emplace_back("initial_infected");
    names__.emplace_back("sigma_obs");
    names__.emplace_back("severity");
    names__.emplace_back("omicron_trans_multiplier");
    names__.emplace_back("test_delay");
    names__.emplace_back("hosp_delta");
    names__.emplace_back("cases_delta");
    names__.emplace_back("beta_multiplier");
    names__.emplace_back("x");
    names__.emplace_back("sim_data");
    names__.emplace_back("new_cases");
    names__.emplace_back("soon_positive");
    names__.emplace_back("beta");
    names__.emplace_back("frac_hosp_0");
    names__.emplace_back("sim_data_with_error");
    names__.emplace_back("Rt");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nobs_types)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(ninter)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(ncompartments)
                                             , static_cast<size_t>(nt)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nobs_types),
                                             static_cast<size_t>(nt)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nt)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nt)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nt)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nobs_types),
                                             static_cast<size_t>(nt)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(nt)});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "duration_latent");
    param_names__.emplace_back(std::string() + "duration_rec_mild");
    param_names__.emplace_back(std::string() + "duration_pre_hosp");
    param_names__.emplace_back(std::string() + "duration_hosp_mod");
    param_names__.emplace_back(std::string() + "duration_protection_infection");
    param_names__.emplace_back(std::string() + "frac_tested");
    param_names__.emplace_back(std::string() + "initial_infected");
    for (int sym1__ = 1; sym1__ <= nobs_types; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "sigma_obs" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "severity");
    param_names__.emplace_back(std::string() + "omicron_trans_multiplier");
    param_names__.emplace_back(std::string() + "test_delay");
    param_names__.emplace_back(std::string() + "hosp_delta");
    param_names__.emplace_back(std::string() + "cases_delta");
    for (int sym1__ = 1; sym1__ <= ninter; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta_multiplier" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= ncompartments; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "x" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nobs_types; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "sim_data" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "new_cases" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "soon_positive" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
        }}
      param_names__.emplace_back(std::string() + "frac_hosp_0");
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nobs_types; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "sim_data_with_error" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "Rt" + '.' + std::to_string(sym1__));
        }}
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "duration_latent");
    param_names__.emplace_back(std::string() + "duration_rec_mild");
    param_names__.emplace_back(std::string() + "duration_pre_hosp");
    param_names__.emplace_back(std::string() + "duration_hosp_mod");
    param_names__.emplace_back(std::string() + "duration_protection_infection");
    param_names__.emplace_back(std::string() + "frac_tested");
    param_names__.emplace_back(std::string() + "initial_infected");
    for (int sym1__ = 1; sym1__ <= nobs_types; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "sigma_obs" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "severity");
    param_names__.emplace_back(std::string() + "omicron_trans_multiplier");
    param_names__.emplace_back(std::string() + "test_delay");
    param_names__.emplace_back(std::string() + "hosp_delta");
    param_names__.emplace_back(std::string() + "cases_delta");
    for (int sym1__ = 1; sym1__ <= ninter; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "beta_multiplier" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= ncompartments; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "x" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nobs_types; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "sim_data" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "new_cases" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "soon_positive" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "beta" + '.' + std::to_string(sym1__));
        }}
      param_names__.emplace_back(std::string() + "frac_hosp_0");
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= nobs_types; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "sim_data_with_error" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= nt; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "Rt" + '.' + std::to_string(sym1__));
        }}
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"duration_latent\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"duration_rec_mild\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"duration_pre_hosp\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"duration_hosp_mod\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"duration_protection_infection\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"frac_tested\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"initial_infected\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_obs\",\"type\":{\"name\":\"array\",\"length\":" << nobs_types << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"severity\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"omicron_trans_multiplier\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"test_delay\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"hosp_delta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"cases_delta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_multiplier\",\"type\":{\"name\":\"array\",\"length\":" << ninter << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"x\",\"type\":{\"name\":\"matrix\",\"rows\":" << ncompartments << ",\"cols\":" << nt << "},\"block\":\"transformed_parameters\"},{\"name\":\"sim_data\",\"type\":{\"name\":\"matrix\",\"rows\":" << nobs_types << ",\"cols\":" << nt << "},\"block\":\"transformed_parameters\"},{\"name\":\"new_cases\",\"type\":{\"name\":\"vector\",\"length\":" << nt << "},\"block\":\"transformed_parameters\"},{\"name\":\"soon_positive\",\"type\":{\"name\":\"vector\",\"length\":" << nt << "},\"block\":\"transformed_parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"array\",\"length\":" << nt << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"frac_hosp_0\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sim_data_with_error\",\"type\":{\"name\":\"matrix\",\"rows\":" << nobs_types << ",\"cols\":" << nt << "},\"block\":\"generated_quantities\"},{\"name\":\"Rt\",\"type\":{\"name\":\"array\",\"length\":" << nt << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"duration_latent\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"duration_rec_mild\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"duration_pre_hosp\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"duration_hosp_mod\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"duration_protection_infection\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"frac_tested\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"initial_infected\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_obs\",\"type\":{\"name\":\"array\",\"length\":" << nobs_types << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"severity\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"omicron_trans_multiplier\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"test_delay\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"hosp_delta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"cases_delta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_multiplier\",\"type\":{\"name\":\"array\",\"length\":" << ninter << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"x\",\"type\":{\"name\":\"matrix\",\"rows\":" << ncompartments << ",\"cols\":" << nt << "},\"block\":\"transformed_parameters\"},{\"name\":\"sim_data\",\"type\":{\"name\":\"matrix\",\"rows\":" << nobs_types << ",\"cols\":" << nt << "},\"block\":\"transformed_parameters\"},{\"name\":\"new_cases\",\"type\":{\"name\":\"vector\",\"length\":" << nt << "},\"block\":\"transformed_parameters\"},{\"name\":\"soon_positive\",\"type\":{\"name\":\"vector\",\"length\":" << nt << "},\"block\":\"transformed_parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"array\",\"length\":" << nt << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"frac_hosp_0\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sim_data_with_error\",\"type\":{\"name\":\"matrix\",\"rows\":" << nobs_types << ",\"cols\":" << nt << "},\"block\":\"generated_quantities\"},{\"name\":\"Rt\",\"type\":{\"name\":\"array\",\"length\":" << nt << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }
    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }
    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  
    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        
};
}
using stan_model = model_LEMMA_namespace::model_LEMMA;
#ifndef USING_R
// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return model_LEMMA_namespace::profiles__;
}
#endif
#endif
